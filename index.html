<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no">
    <title>Circle Coverage Problem</title>

    <link href="css/nihilo.css" rel="stylesheet" />
    <link href="css/esri.css" rel="stylesheet" />

    <!--<link rel="stylesheet" href="https://js.arcgis.com/3.32/dijit/themes/nihilo/nihilo.css">
    <link rel="stylesheet" href="https://js.arcgis.com/3.32/esri/css/esri.css">-->
    <!--<link href="css/bootstrap.css" rel="stylesheet" />-->
    <style>


        html, body, #mainWindow {
            font-family: sans-serif;
            height: 100%;
            width: 100%;
        }


        html, body {
            margin: 0;
            padding: 0;
        }

        #header {
            height: 110px;
            overflow: auto;
            padding: 0.5em;
        }
    </style>
    <script src="https://js.arcgis.com/3.32/"></script>
    <script src="js/Binary_Cross_Over.js"></script>
    <script src="js/Grid_Analysis.js"></script>
    <script src="js/Grid_Drawing.js"></script>
    <script src="js/Random_Seed.js"></script>
    <script src="js/Shape_Seed.js"></script>
    <script src="js/Generation_Helpers.js"></script>
    <script src="js/Fitness_Value_Calculations.js"></script>
    <script src="js/Mid_Point_Cross_Over.js"></script>
    <script src="js/Binary_Point_Mutate.js"></script>
    <script src="js/Decimal_Point_Mutate.js"></script>
    <script src="js/Mid_Point_Mutate.js"></script>
    <script src="simplexsolver/glpk.min.js"></script>

    <script>
        var map, toolbar, symbol, geomTask;

        require([
            "esri/map",
            "esri/toolbars/draw",
            "esri/graphic",
            "esri/symbols/SimpleMarkerSymbol",
            "esri/symbols/SimpleLineSymbol",
            "esri/symbols/SimpleFillSymbol",
            "dojo/parser", "dijit/registry",
            "esri/geometry/Extent",
            "esri/geometry/Polygon",
            "esri/layers/GraphicsLayer",
            "esri/geometry/Circle",
            "esri/symbols/Font",
            "esri/symbols/TextSymbol",
            "esri/geometry/geodesicUtils",
            "esri/tasks/GeometryService",
            "esri/tasks/AreasAndLengthsParameters",
            "dijit/layout/BorderContainer", "dijit/layout/ContentPane",
            "dijit/form/Button", "dijit/WidgetSet", "dojo/domReady!"
        ], function (Map, Draw, Graphic, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, parser, registry, Extent, Polygon, GraphicsLayer, Circle, Font, TextSymbol, geodesicUtils, GeometryService, AreasAndLengthsParameters) {

            parser.parse();

            //var geometryService = new GeometryService("https://sampleserver6.arcgisonline.com/arcgis/rest/services/Utilities/Geometry/GeometryServer");
            //var geometryService = new esri.tasks.GeometryService("https://utility.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer");
            var geometryService = new GeometryService("https://utility.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer");
            //geometryService.on("areas-and-lengths-complete", outputAreaAndLength);




            // Dehli
            //var initialExtent = new Extent({
            //    "xmin": 8587051.99,
            //    "ymin": 3321509.58,
            //    "xmax": 8612486.41,
            //    "ymax": 3332975.13,
            //    "spatialReference": { "wkid": 102100 }
            //});

            //Islamabd
            var initialExtent = new Extent({
                "xmin": 8108000.13,
                "ymin": 3973024.59,
                "xmax": 8158868.97,
                "ymax": 3995955.69,
                "spatialReference": { "wkid": 102100 }
            });

            // basemap: "topo",
            // basemap: "streets",
            var map = new Map("map", {
                basemap: "topo",
                extent: initialExtent,
                zoom: 13
            });

            var ist_exectution = true;
            var hand_drawn_polygon_by_user;


            var graphics_layer = new esri.layers.GraphicsLayer({ id: "circlecovg_graphics_layer" });
            map.addLayer(graphics_layer);

            map.on("load", createToolbar);

            // loop through all dijits, connect onClick event
            // listeners for buttons to activate drawing tools
            registry.forEach(function (d) {

                // d is a reference to a dijit
                // could be a layout container or a button
                if (d.declaredClass === "dijit.form.Button" && d.id === "btnDrawPolygon") {
                    d.on("click", activateTool);
                }


                if (d.declaredClass === "dijit.form.Button" && d.id === "btnReevaluatePolygonCoverage") {
                    d.on("click", btnReevaluatePolygonCoverage_Handler);
                }


                if (d.declaredClass === "dijit.form.Button" && d.id === "btnClearMap") {
                    d.on("click", btnClearMap_Handler);
                }

                if (d.declaredClass === "dijit.form.Button" && d.id === "btnResetGAParams") {
                    d.on("click", btnResetGAParams_Handler);
                }


                if (d.declaredClass === "dijit.form.Button" && d.id === "btnExecutAlgo") {
                    d.on("click", execut_algo_saved_polygon);
                }

            });



            function btnReevaluatePolygonCoverage_Handler() {


                if (hand_drawn_polygon_by_user == null) {
                    return null;
                }

                execut_algo(hand_drawn_polygon_by_user);

                //alert("btnReevaluatePolygonCoverage_Handler");

                //var map_graphics_layer = map.getLayer("circlecovg_graphics_layer");

                //if (map_graphics_layer == null) { return; }

                //var all_graphics = map_graphics_layer.graphics;

                //for (var i = 0; i < all_graphics.length; i++) {

                //    //if (console.log(all_graphics[i].data-geometry-type))
                //    //console.log(all_graphics[i].toJson());

                //    console.log(all_graphics[i].symbol.style);
                //    console.log(all_graphics[i].symbol.type);

                //}

            }




            function btnResetGAParams_Handler() {
                Reset_UI_To_Start_Over();
            }


            function btnClearMap_Handler() {
                //alert("clear called");
                hand_drawn_polygon_by_user = null;
                graphics_layer.clear();
            }


            function Generate_NOT_Numbers() {

                console.log(~5 >>> 26);

                console.log("~0 ===========> " + ~0);
                console.log("~1 ===========> " + ~1);
                console.log("~2 ===========> " + ~2);
                console.log("~3 ===========> " + ~3);
                console.log("~4 ===========> " + ~4);
                console.log("~5 ===========> " + ~5);
                console.log("~6 ===========> " + ~6);
                console.log("~7 ===========> " + ~7);
                console.log("~8 ===========> " + ~8);
                console.log("~9 ===========> " + ~9);
                console.log("~10 ===========> " + ~10);
                console.log("~11 ===========> " + ~11);
                console.log("~12 ===========> " + ~12);
                console.log("~13 ===========> " + ~13);
                console.log("~14 ===========> " + ~14);
                console.log("~15 ===========> " + ~15);

            }


            function execut_algo_saved_polygon() {
                hand_drawn_polygon_by_user = null;
                execut_algo(null);
            }



            // run the solver
            function Execute_Model_Solver(model) {

                try {

                    // create lp object
                    var lp = glp_create_prob();

                    // read the model from text area, while reading also pass lp
                    // lp is loaded with the model text
                    glp_read_lp_from_string(lp, null, model);

                    // do some processing on lp solver loaded with model
                    glp_scale_prob(lp, GLP_SF_AUTO);

                    //GLPK Simplex Optimizer
                    var smcp = new SMCP({ presolve: GLP_ON });

                    // do some processing on lp solver loaded with model and smcp
                    glp_simplex(lp, smcp);

                    //GLPK Integer Optimizer
                    var iocp = new IOCP({ presolve: GLP_ON });

                    // do some processing on lp solver loaded with model and iocp
                    //GLPK Integer Optimizer

                    glp_intopt(lp, iocp);

                    //glp_intopt(lp);


                    var result = [], objective;
                    var circle_count = [];


                    // objective function value
                    var glp_mip_obj_value = glp_mip_obj_val(lp);
                    console.log("Circle Coverage: " + glp_mip_obj_value);

                    // number of variables in the model
                    var glp_get_num_of_columns = glp_get_num_cols(lp);



                    // print variable names and variable values
                    for (var i = 1; i <= glp_get_num_of_columns; i++) {
                        console.log(glp_get_col_name(lp, i) + " = " + glp_mip_col_val(lp, i));
                        //result[glp_get_col_name(lp, i)] = glp_mip_col_val(lp, i);
                        circle_count[i - 1] = glp_mip_col_val(lp, i);
                    }


                    lp = null;

                    result[0] = glp_mip_obj_value;
                    result[1] = circle_count;

                    return result;

                } catch (err) {

                    console.log(err);

                } finally {

                }


            }



            async function execut_algo(hand_drawn_polygon_by_user) {


                var polygon_selector = parseInt(document.getElementById('selectPolygon').value); // 75 %
                //var polygon_area_margin = parseInt(document.getElementById('txtAreaMargin').value); // 50 %

                var polygon_drawings_results;
                var polygon;
                var polygon_graphic;
                var polygon_extent;


                if (hand_drawn_polygon_by_user == null) {

                    polygon_drawings_results = get_polygon(polygon_selector);
                    polygon = polygon_drawings_results[0];
                    polygon_graphic = polygon_drawings_results[1];
                    polygon_extent = polygon.getExtent();

                }


                if (hand_drawn_polygon_by_user != null) {
                    polygon = hand_drawn_polygon_by_user;
                    polygon_extent = hand_drawn_polygon_by_user.getExtent();
                }


                var polygon_extent_polygon = Polygon.fromExtent(polygon_extent);
                var polygon_area = 0;

                //UNIT_METER UNIT_KILOMETER UNIT_SQUARE_METERS UNIT_SQUARE_KILOMETERS UNIT_SQUARE_MILES
                //setup the parameters for the areas and lengths operation
                var areasAndLengthParams = new AreasAndLengthsParameters();
                areasAndLengthParams.lengthUnit = GeometryService.UNIT_METER;
                areasAndLengthParams.areaUnit = GeometryService.UNIT_SQUARE_METERS;
                areasAndLengthParams.calculationType = "geodesic"; //planar, geodesic, preserveShape


                await geometryService.simplify([polygon_extent_polygon], function (simplifiedGeometries) {
                    // Polygon geometries for which to compute areas and lengths
                    areasAndLengthParams.polygons = simplifiedGeometries;
                    geometryService.areasAndLengths(areasAndLengthParams, function (measurements) {
                        // do something with the results here

                        var initia_polygon_area = parseInt(measurements.areas[0].toFixed(0));

                        //var percent_increase = (initia_polygon_area * (polygon_area_margin / 100)).toFixed(0);
                        //polygon_area = parseInt(initia_polygon_area) + parseInt(percent_increase);
                        polygon_area = initia_polygon_area;

                        console.log("result" + measurements);
                        console.log("area " + measurements.areas[0].toFixed(3) + " m2");
                        console.log("length " + measurements.lengths[0].toFixed(3) + " m");
                        execut_algo2(polygon, polygon_extent, polygon_area);
                    });
                });



            }



            function Find_Circles_Required_To_Cover_Polygon(
                circle_areas_list,
                polygon_area,
                polygon_area_margin_in_perc,
                polygon_bounds_margin_in_perc) {


                var polygon_area_margin = (polygon_bounds_margin_in_perc / 100) * polygon_area;
                polygon_area_margin = polygon_area_margin.toFixed(0);


                var min_polygon_area = parseInt(polygon_area) - parseInt(polygon_area_margin);
                var max_polygon_area = parseInt(polygon_area) + parseInt(polygon_area_margin);

                var circle_areas_for_polygon_index = 0;
                var circle_areas_list_index = 0;// set to biggest circle
                var circle_areas_for_polygon = [];
                var circle_areas_count_for_polygon = [];
                var smallest_circle_area = circle_areas_list[circle_areas_list.length - 1];

                for (var i = 0; i < circle_areas_list.length; i++) {
                    circle_areas_count_for_polygon[i] = 0;
                }


                var remaining_polygon_area = max_polygon_area;

                while (remaining_polygon_area > smallest_circle_area) {

                    // Circle perfectly covers the area then use that circle for coverage
                    // if one big circle covers 90% of polygon and leaves 10% un covered then it is ok
                    // if one big circle covers 110% of polygon and provides 10% extra coverage then it is ok
                    // algo will start with biggest circle first as circle_areas_list_index = 0

                    if (circle_areas_list[circle_areas_list_index] >= min_polygon_area && circle_areas_list[circle_areas_list_index] <= max_polygon_area) {
                        circle_areas_for_polygon[circle_areas_for_polygon_index] = circle_areas_list[circle_areas_list_index];
                        circle_areas_count_for_polygon[circle_areas_list_index] = circle_areas_count_for_polygon[circle_areas_list_index] + 1;
                        remaining_polygon_area = remaining_polygon_area - circle_areas_list[circle_areas_list_index];
                        circle_areas_for_polygon_index++;

                        polygon_area_margin = (polygon_bounds_margin_in_perc / 100) * remaining_polygon_area;
                        polygon_area_margin = polygon_area_margin.toFixed(0);
                        min_polygon_area = parseInt(remaining_polygon_area) - parseInt(polygon_area_margin);
                        max_polygon_area = parseInt(remaining_polygon_area) + parseInt(polygon_area_margin);

                        continue;// check remaining polygon area
                    }



                    //when polygon is huge and biggest available circle is very small in comparision
                    // add it as we are left with no bigger circle option. USE IT
                    if (circle_areas_list[circle_areas_list_index] < min_polygon_area && circle_areas_list_index == 0) {
                        circle_areas_for_polygon[circle_areas_for_polygon_index] = circle_areas_list[circle_areas_list_index];
                        circle_areas_count_for_polygon[circle_areas_list_index] = circle_areas_count_for_polygon[circle_areas_list_index] + 1;
                        remaining_polygon_area = remaining_polygon_area - circle_areas_list[circle_areas_list_index];
                        circle_areas_for_polygon_index++;

                        polygon_area_margin = (polygon_bounds_margin_in_perc / 100) * remaining_polygon_area;
                        polygon_area_margin = polygon_area_margin.toFixed(0);
                        min_polygon_area = parseInt(remaining_polygon_area) - parseInt(polygon_area_margin);
                        max_polygon_area = parseInt(remaining_polygon_area) + parseInt(polygon_area_margin);

                        continue;// check remaining polygon area
                    }



                    //when polygon is very tiny and smallest available circle is very big in comparision
                    // add it as we are left with no smaller circle option.
                    if (circle_areas_list[circle_areas_list_index] > min_polygon_area && circle_areas_list_index == circle_areas_list.length - 1) {
                        circle_areas_for_polygon[circle_areas_for_polygon_index] = circle_areas_list[circle_areas_list_index];
                        circle_areas_count_for_polygon[circle_areas_list_index] = circle_areas_count_for_polygon[circle_areas_list_index] + 1;
                        remaining_polygon_area = remaining_polygon_area - circle_areas_list[circle_areas_list_index];
                        circle_areas_for_polygon_index++;

                        polygon_area_margin = (polygon_bounds_margin_in_perc / 100) * remaining_polygon_area;
                        polygon_area_margin = polygon_area_margin.toFixed(0);
                        min_polygon_area = parseInt(remaining_polygon_area) - parseInt(polygon_area_margin);
                        max_polygon_area = parseInt(remaining_polygon_area) + parseInt(polygon_area_margin);

                        continue;// check remaining polygon area
                    }


                    // NEW
                    //when polygon is very tiny and smallest available circle is very big in comparision
                    // add it as we are left with no smaller circle option.
                    if (circle_areas_list[circle_areas_list_index] < min_polygon_area && circle_areas_list_index == circle_areas_list.length - 1) {
                        circle_areas_for_polygon[circle_areas_for_polygon_index] = circle_areas_list[circle_areas_list_index];
                        circle_areas_count_for_polygon[circle_areas_list_index] = circle_areas_count_for_polygon[circle_areas_list_index] + 1;
                        remaining_polygon_area = remaining_polygon_area - circle_areas_list[circle_areas_list_index];
                        circle_areas_for_polygon_index++;

                        polygon_area_margin = (polygon_bounds_margin_in_perc / 100) * remaining_polygon_area;
                        polygon_area_margin = polygon_area_margin.toFixed(0);
                        min_polygon_area = parseInt(remaining_polygon_area) - parseInt(polygon_area_margin);
                        max_polygon_area = parseInt(remaining_polygon_area) + parseInt(polygon_area_margin);

                        continue;// check remaining polygon area
                    }



                    // means circle is small, and polygon is big, and we have bigger circle options, we will try bigger circle
                    // means circle covers 89% of polygon and leaves 11% un covered, not OK
                    // we will try bigger circles in ascending order
                    if (circle_areas_list[circle_areas_list_index] < min_polygon_area) {

                        circle_areas_for_polygon[circle_areas_for_polygon_index] = circle_areas_list[circle_areas_list_index];
                        circle_areas_count_for_polygon[circle_areas_list_index] = circle_areas_count_for_polygon[circle_areas_list_index] + 1;
                        remaining_polygon_area = remaining_polygon_area - circle_areas_list[circle_areas_list_index];
                        circle_areas_for_polygon_index++;

                        polygon_area_margin = (polygon_bounds_margin_in_perc / 100) * remaining_polygon_area;
                        polygon_area_margin = polygon_area_margin.toFixed(0);
                        min_polygon_area = parseInt(remaining_polygon_area) - parseInt(polygon_area_margin);
                        max_polygon_area = parseInt(remaining_polygon_area) + parseInt(polygon_area_margin);

                        continue;

                        //circle_areas_list_index--;
                        //continue;
                    }


                    // means circle is big, and polygon is small, and we have smaller circle options, we will try smaller circle
                    // means circle covers 111+% of polygon and provides 11+% extra coverage not required
                    // we will try smaller circles in decending order
                    if (circle_areas_list[circle_areas_list_index] > max_polygon_area) {
                        circle_areas_list_index++;
                        continue;
                    }

                }// while

                return circle_areas_count_for_polygon;
                //return circle_areas_for_polygon;


            }



            function Find_Circles_Required_To_Cover_Polygon_By_Model_Solver_Again(
                selected_radii_area,
                increased_polygon_area,
                pervious_circle_count) {


                var coverage_model_string = "";
                coverage_model_string = coverage_model_string + "Maximize \nobj: ";

                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + " + " + selected_radii_area[i][1] + " circle_" + selected_radii_area[i][0];
                }

                coverage_model_string = coverage_model_string + "\n\nSubject To \ncap: ";


                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + " + " + selected_radii_area[i][1] + " circle_" + selected_radii_area[i][0];
                }

                coverage_model_string = coverage_model_string + " <= " + increased_polygon_area + "\n";


                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + " + circle_" + selected_radii_area[i][0];
                }

                coverage_model_string = coverage_model_string + " <= " + pervious_circle_count;


                coverage_model_string = coverage_model_string + "\n\nBounds\n";

                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + " 0 <= " + " circle_" + selected_radii_area[i][0] + " <= 50000\n";
                }

                coverage_model_string = coverage_model_string + "\nGeneral\n";


                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + "circle_" + selected_radii_area[i][0] + "\n";
                }

                coverage_model_string = coverage_model_string + "End\n";

                //alert(coverage_model_string);
                console.log(coverage_model_string);

                var result = [];
                var circle_radii_array = [];
                var circle_radii_array_index = 0;

                var model_solver_results = Execute_Model_Solver(coverage_model_string);

                for (var i = 0; i < model_solver_results[1].length; i++) {

                    for (var j = 0; j < model_solver_results[1][i]; j++) {

                        circle_radii_array[circle_radii_array_index] = selected_radii_area[i][0];
                        circle_radii_array_index++;
                    }

                }

                result[0] = model_solver_results[0];
                result[1] = circle_radii_array;

                return result;


            }



            function Find_Circles_Required_To_Cover_Polygon_By_Model_Solver(
                selected_radii_area,
                increased_polygon_area) {

                var coverage_model_string = "";
                coverage_model_string = coverage_model_string + "Maximize \nobj: ";

                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + " + " + selected_radii_area[i][1] + " circle_" + selected_radii_area[i][0];
                }

                coverage_model_string = coverage_model_string + "\n\nSubject To \ncap: ";


                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + " + " + selected_radii_area[i][1] + " circle_" + selected_radii_area[i][0];
                }

                coverage_model_string = coverage_model_string + " <= " + increased_polygon_area + "\n\nBounds\n";

                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + " 0 <= " + " circle_" + selected_radii_area[i][0] + " <= 50000\n";
                }

                coverage_model_string = coverage_model_string + "\nGeneral\n";


                for (var i = 0; i < selected_radii_area.length; i++) {
                    coverage_model_string = coverage_model_string + "circle_" + selected_radii_area[i][0] + "\n";
                }

                coverage_model_string = coverage_model_string + "End\n";

                //alert(coverage_model_string);
                console.log(coverage_model_string);

                var result = [];
                var circle_radii_array = [];
                var circle_radii_array_index = 0;

                var model_solver_results = Execute_Model_Solver(coverage_model_string);

                for (var i = 0; i < model_solver_results[1].length; i++) {

                    for (var j = 0; j < model_solver_results[1][i]; j++) {

                        circle_radii_array[circle_radii_array_index] = selected_radii_area[i][0];
                        circle_radii_array_index++;
                    }

                }

                result[0] = model_solver_results[0];
                result[1] = circle_radii_array;

                return result;


            }


            function Reset_UI_To_Start_Over() {

                document.getElementById('txtAreaMargin').value = 0;
                ist_exectution = true;
            }


            function execut_algo2(polygon, polygon_extent, polygon_area) {

                //alert("polygon_area" + polygon_area);

                // FETCH VALUES ONCE

                var number_of_circles;// = parseInt(document.getElementById('txtCircles').value);
                var radius_of_circle_in_meters;// = parseInt(document.getElementById('txtRadius').value); // in km
                var grid_length = parseInt(document.getElementById('txtGridLength').value);
                var random_generation_record_count = parseInt(document.getElementById('txtRandomSet').value);
                var number_of_records_in_each_crossover_generations = parseInt(document.getElementById('txtCrossOverSet').value);
                var number_of_top_records_goto_to_next_generation = parseInt(document.getElementById('txtPrevGenerationSets').value);
                var generation_count = parseInt(document.getElementById('txtGenerations').value);
                var number_of_crossovers_before_mutations = parseInt(document.getElementById('txtMutateAfter').value);
                var polygon_area_margin = parseInt(document.getElementById('txtAreaMargin').value); // 50 %
                var polygon_bounds_margin = parseInt(document.getElementById('txtBoundMargin').value); // 20 %
                var grid_buffer_x = 0;
                var grid_buffer_y = 0;
                var polygon_selector = parseInt(document.getElementById('selectPolygon').value); // 75 %
                var ideal_circle_coverage_count_on_grid = 0;
                var isUseModelSolver = document.getElementById('ckbModelSolver').checked;



                var rdobtn_fitfun = document.getElementsByName("rdobtn_fitfun[]");
                var fitness_function_selector = 1;

                for (var i = 0; i < rdobtn_fitfun.length; i++) {

                    if (rdobtn_fitfun[i].checked == true) {
                        fitness_function_selector = parseInt(rdobtn_fitfun[i].value);
                        break;
                    }
                }

                var rdobtn_outsidecovgfilter = document.getElementsByName("rdobtn_outsidecovgfilter[]");
                var outside_covg_filter_selector = 1;

                for (var i = 0; i < rdobtn_outsidecovgfilter.length; i++) {

                    if (rdobtn_outsidecovgfilter[i].checked == true) {
                        outside_covg_filter_selector = parseInt(rdobtn_outsidecovgfilter[i].value);
                        break;
                    }
                }


                var selected_radii_area = [];
                var selected_circle_areas_list = [];
                var selected_radii_index = 0;
                var chkbox_radii = document.getElementsByName("chkbox_radii[]");


                for (var i = 0; i < chkbox_radii.length; i++) {
                    if (chkbox_radii[i].checked == true) {

                        var radii_area_element = [];

                        radii_area_element[0] = parseInt(chkbox_radii[i].value);
                        radii_area_element[1] = parseInt((3.142857142857143 * chkbox_radii[i].value * chkbox_radii[i].value).toFixed(0));

                        selected_circle_areas_list[selected_radii_index] = parseInt((3.142857142857143 * chkbox_radii[i].value * chkbox_radii[i].value).toFixed(0));

                        selected_radii_area[selected_radii_index] = radii_area_element;
                        selected_radii_index++;

                    }
                }


                if (selected_radii_area.length <= 0) {
                    alert("Please select some radii.");
                    return;
                }


                // FETCH VALUES ONCE


                // NOT NEEDED IN LOOPS
                if (ist_exectution) {
                    ist_exectution = false;
                }
                else if (polygon_area_margin == 100) {
                    polygon_area_margin = 0;
                    document.getElementById('txtAreaMargin').value = polygon_area_margin;
                }
                else {
                    polygon_area_margin = polygon_area_margin + 5;
                    document.getElementById('txtAreaMargin').value = polygon_area_margin;
                }
                // NOT NEEDED IN LOOPS


                // VALIDATION CHECKS ONCE NEEDED/////////////////////////////////////////

                if (grid_length % 2 == 0) {
                    alert("For better results, Grid Length must be ODD number");
                    return;
                }


                if (random_generation_record_count < number_of_top_records_goto_to_next_generation) {
                    alert("Random-Generation-Records should be greater or equal to Records-Taken-From-Previous-Generation");
                    return;
                }

                if (number_of_top_records_goto_to_next_generation > number_of_records_in_each_crossover_generations) {
                    alert("Records-Taken-From-Previous-Generation should be less than or equal to Records-In-CrossOver-Generatoin");
                    return;
                }

                if (number_of_top_records_goto_to_next_generation < 2) {
                    alert("Records-Taken-From-Previous-Generation should be greater than or equal to 2");
                    return;
                }

                if (number_of_records_in_each_crossover_generations < 2) {
                    alert("Records-In-CrossOver-Generatoin should be greater than or equal to 2");
                    return;
                }


                if (polygon_area_margin < 0) {
                    alert("Polygoin area margin in percentage should be greater than or equal to 1");
                    return;
                }

                if (polygon_bounds_margin < 1) {
                    alert("Polygoin bounds margin in percentage should be greater than 1");
                    return;
                }

                // VALIDATION CHECKS ONCE NEEDED/////////////////////////////////////////

                var startTime = performance.now();

                console.clear();
                graphics_layer.clear();

                //var polygon_margin_array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
                var polygon_margin_array = [10, 20, 30, 40, 50];
                var all_ga_results_array = [];
                var all_ga_results_array_index = 0;

                for (var iindex = 0; iindex < polygon_margin_array.length; iindex++) {


                    polygon_area_margin = polygon_margin_array[iindex];


                    var circle_radii_array = [];
                    var circle_radii_array_index = 0;

                    var increased_polygon_area = polygon_area + parseInt(((polygon_area_margin / 100) * polygon_area).toFixed(0));
                    //var increased_polygon_area = polygon_area + parseInt(((polygon_area_margin / 100) * polygon_area).toFixed(0));

                    if (increased_polygon_area >= 222222222) {
                        isUseModelSolver = false;
                    }


                    if (!isUseModelSolver) {

                        //alert("going into custom algo");

                        var circle_areaii_array = Find_Circles_Required_To_Cover_Polygon(selected_circle_areas_list,
                            increased_polygon_area,
                            polygon_area_margin,
                            polygon_bounds_margin);

                        for (var i = 0; i < circle_areaii_array.length; i++) {

                            for (var j = 0; j < circle_areaii_array[i]; j++) {

                                circle_radii_array[circle_radii_array_index] = selected_radii_area[i][0];
                                circle_radii_array_index++;
                            }

                        }

                        //alert("coming out of custom algo " + circle_radii_array.length);
                    }

                    else {
                        //////////////////////////////////////////////////////////////////////

                        var algo_model_solvera_results;

                        //alert("going into model. polygon area = " + increased_polygon_area);
                        algo_model_solvera_results = Find_Circles_Required_To_Cover_Polygon_By_Model_Solver(
                            selected_radii_area,
                            increased_polygon_area);

                        var termination_flag = false;
                        var pervious_circle_count = 0;
                        var pervious_area_coverage = 0;
                        var previous_algo_model_solvera_results;
                        var percent_area_compormised = 0;

                        while (!termination_flag) {

                            previous_algo_model_solvera_results = algo_model_solvera_results;
                            pervious_circle_count = algo_model_solvera_results[1].length;
                            pervious_area_coverage = algo_model_solvera_results[0];

                            algo_model_solvera_results = Find_Circles_Required_To_Cover_Polygon_By_Model_Solver_Again(
                                selected_radii_area,
                                increased_polygon_area,
                                pervious_circle_count - 1);


                            percent_area_compormised = (((increased_polygon_area - algo_model_solvera_results[0]) / increased_polygon_area) * 100).toFixed(0);

                            percent_area_compormised = parseInt(percent_area_compormised);

                            //algo_model_solvera_results[0] == 0 ||

                            if (algo_model_solvera_results[1].length >= pervious_circle_count ||
                                algo_model_solvera_results[0] < polygon_area ||
                                percent_area_compormised > 5) {

                                circle_radii_array = previous_algo_model_solvera_results[1];
                                termination_flag = true;
                                break;

                            }
                            else {
                                circle_radii_array = algo_model_solvera_results[1];
                            }

                        }


                        //alert("out from model  " + circle_radii_array.length);
                        /////////////////////////////////////////////////////////////////////////
                    }


                    //alert("polygon area" + increased_polygon_area + "\ncovered polygon area" + algo_model_solvera_results[0]);

                    number_of_circles = circle_radii_array.length;


                    if (number_of_circles <= 0) {
                        alert("Selected Circles are way too big for given Polygon. Select some smaller Circles Radii.");
                        return;
                    }

                    //var lat_long_grid = Generate_Lat_Long_Grid(polygon_extent, grid_length);
                    var latlong_grid = Generate_Lat_Long_Points_Grid(polygon_extent, grid_length, map);
                    var index_grid = Generate_Cartesian_Grid(grid_length);

                    //console.log("lat_long_grid");
                    //Print_Grid_Spatially_Like_Map(lat_long_grid);
                    //console.log("lat_long_point_grid");
                    //Print_Grid_Points_Spatially_Like_Map(latlong_grid);
                    //console.log("index_grid");


                    //Print_Grid_Spatially_Like_Map(index_grid);
                    Show_Grid_Points_On_Map(graphics_layer, latlong_grid);

                    //var polygon_coverage = get_polygon_coverage_on_latlong_grid(polygon, latlong_grid);

                    var result_array = get_polygon_coverage_on_latlong_cartesian_grid(polygon, latlong_grid);

                    // lat long points array
                    var polygon_coverage_on_latlong_grid = result_array[0];
                    // cartesian points array
                    var polygon_coverage_on_cartesian_grid = result_array[1];

                    var latlong_grid_center = (grid_length - 1) / 2;
                    var latlong_grid_center_point = latlong_grid[latlong_grid_center][latlong_grid_center];


                    for (var i = 0; i < circle_radii_array.length; i++) {

                        var circle_on_grid_center = get_circle_polygon(latlong_grid_center_point, circle_radii_array[i]);

                        ideal_circle_coverage_count_on_grid = ideal_circle_coverage_count_on_grid +
                            get_polygon_coverage_count_on_latlong_grid(circle_on_grid_center, latlong_grid);

                    }


                    var cartesian_generation = Get_Initial_Cartesian_Generation_By_Random_Function_Map_Polygon(
                        grid_length,
                        polygon_coverage_on_cartesian_grid,
                        random_generation_record_count,
                        grid_buffer_x,
                        grid_buffer_y,
                        number_of_circles);

                    // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                    console.log("Initial Seed Random Generation");
                    console.log("===============");
                    Print_Generation(cartesian_generation);
                    console.log("===============");

                    //var mutated_cartesian_generation = Mutate_Cartesian_Generation(
                    //    cartesian_generation,
                    //    polygon_coverage_on_cartesian_grid,
                    //    grid_length);
                    //console.log("Mutated Initial Seed Random Generation");
                    //console.log("===============");
                    //Print_Generation(mutated_cartesian_generation);
                    //console.log("===============");


                    var all_records_list = Evaluate_FitnessValue_Of_Seed_Generation_Return_All_Records_GIS(
                        cartesian_generation,
                        map,
                        polygon,
                        polygon_coverage_on_latlong_grid,
                        latlong_grid,
                        circle_radii_array,
                        number_of_circles,
                        fitness_function_selector,
                        ideal_circle_coverage_count_on_grid,
                        polygon_coverage_on_cartesian_grid);


                    var master_record = [];

                    // sorted generation table of previous iteration
                    master_record[0] = all_records_list;

                    // one topper generation table record of previous iteration
                    master_record[1] = all_records_list[0];

                    // sorted generation table of all iterations, it is not maintined in corss over generations
                    // but here we are sending it for start. rethink this
                    master_record[2] = [];

                    // sorted generation table of TOPPERS all iterations
                    // initially it will have only one record
                    // topper record
                    var top_records_list = [];// to give a shape to Generation table
                    top_records_list[0] = all_records_list[0];
                    master_record[3] = top_records_list;


                    for (var iteration_count = 0; iteration_count < generation_count; iteration_count++) {

                        master_record = GENETIC_ALGO_To_Evaluate_FitnessValue_Of_Generation_With_Binary_CrossOver_Map_Configurable(
                            iteration_count,  //  1 iteration count
                            master_record[3], //  2 toppers records list, sorted generation table of TOPPERS all iterations
                            master_record[0], //  3 prev_gen_record_list, sorted generation table of previous iteration
                            master_record[2], //  4 all_records_list, sorted generation table of all iterations
                            cartesian_generation, //5
                            map,                  //6
                            polygon,              //7
                            polygon_coverage_on_latlong_grid,   //8
                            polygon_coverage_on_cartesian_grid, //9
                            latlong_grid,       //10
                            number_of_top_records_goto_to_next_generation, //11
                            number_of_records_in_each_crossover_generations, //12
                            number_of_crossovers_before_mutations, //13
                            0, //14
                            circle_radii_array,
                            number_of_circles,
                            fitness_function_selector,
                            ideal_circle_coverage_count_on_grid);

                        if ((iteration_count + 1) % number_of_crossovers_before_mutations == 0) {

                            if ((iteration_count + 1) != generation_count) {

                                var mutated_cartesian_generation = Mutate_Cartesian_Generation(
                                    iteration_count,
                                    master_record[0],
                                    polygon_coverage_on_cartesian_grid,
                                    grid_length,
                                    number_of_circles);

                                master_record[0] = mutated_cartesian_generation;

                                // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                                console.log("Iteration [ " + (iteration_count + 1) + " ] Mutation Performed Successfully.");
                                console.log("===============");
                                Print_Generation(mutated_cartesian_generation);
                                console.log("===============");

                            }
                            //console.error("GENERATION MUTATION PERFORMED SUCCESSFULLY.");
                        }
                    }




                    //  input: sorted generation table of TOPPERS of all iterations
                    //  find the best from the list.
                    var fittest_record_found = Evaluate_FitnessValue_Of_Tieing_Toppers(
                        master_record[3], //toppers_generation_table
                        map,
                        polygon,
                        polygon_coverage_on_latlong_grid,
                        latlong_grid,
                        circle_radii_array,
                        ideal_circle_coverage_count_on_grid,
                        outside_covg_filter_selector);


                    if (circle_radii_array.length <= 6) {

                        // Shuffle the location of all points in record and create new generation.
                        // Shuffle the location of all Circles on map and evaluate thieir fitness.
                        // If there are four circles, then 4x3x2x1 records will be created.
                        var repaired_cartesian_generation = Repair_Fittest_Record_N_Create_Generation(fittest_record_found);

                        var repaired_cartesian_generation_results = Evaluate_FitnessValue_Of_Seed_Generation_Return_All_Records_GIS(
                            repaired_cartesian_generation,
                            map,
                            polygon,
                            polygon_coverage_on_latlong_grid,
                            latlong_grid,
                            circle_radii_array,
                            number_of_circles,
                            fitness_function_selector,
                            ideal_circle_coverage_count_on_grid,
                            polygon_coverage_on_cartesian_grid);



                        var fittest_record_found2 = Evaluate_FitnessValue_Of_Tieing_Toppers(
                            repaired_cartesian_generation_results, //toppers_generation_table
                            map,
                            polygon,
                            polygon_coverage_on_latlong_grid,
                            latlong_grid,
                            circle_radii_array,
                            ideal_circle_coverage_count_on_grid,
                            outside_covg_filter_selector);


                        if (fittest_record_found2 == null || fittest_record_found2.length == 0) {
                            fittest_record_found2 = fittest_record_found;
                        }
                        else {
                            fittest_record_found = fittest_record_found2;
                        }

                        // Add One Missed Polygon-Point to the Record at one time and create generation
                        // If record contains 4 Circle Points, Add one Missed Point to location zeor and create 7 points
                        //
                        var new_generation_with_missing_points = Consider_Missing_Points_N_Create_Generation(fittest_record_found);

                        var new_generation_with_missing_points_results = Evaluate_FitnessValue_Of_Seed_Generation_Return_All_Records_GIS(
                            new_generation_with_missing_points,
                            map,
                            polygon,
                            polygon_coverage_on_latlong_grid,
                            latlong_grid,
                            circle_radii_array,
                            number_of_circles,
                            fitness_function_selector,
                            ideal_circle_coverage_count_on_grid,
                            polygon_coverage_on_cartesian_grid);



                        var fittest_record_found3 = Evaluate_FitnessValue_Of_Tieing_Toppers(
                            new_generation_with_missing_points_results, //toppers_generation_table
                            map,
                            polygon,
                            polygon_coverage_on_latlong_grid,
                            latlong_grid,
                            circle_radii_array,
                            ideal_circle_coverage_count_on_grid,
                            outside_covg_filter_selector);


                        if (fittest_record_found3 == null || fittest_record_found3.length == 0) {
                            fittest_record_found3 = fittest_record_found2;
                        }
                        else {
                            fittest_record_found = fittest_record_found3;
                        }

                    }

                    //var fittest_record_found = master_record[3][0];


                    var remove_eclipsed_circles_cartesian_generation_results = Remove_Eclipsed_Circles_From_Fittest_Record(
                        fittest_record_found,
                        circle_radii_array);

                    //fittest_record_found[1] = remove_eclipsed_circles_cartesian_generation_results[0];
                    circle_radii_array = remove_eclipsed_circles_cartesian_generation_results[1];
                    number_of_circles = remove_eclipsed_circles_cartesian_generation_results[1].length;

                    var fittest_record_found4 = Evaluate_FitnessValue_Of_Seed_Generation_Return_All_Records_GIS(
                        remove_eclipsed_circles_cartesian_generation_results[0],
                        map,
                        polygon,
                        polygon_coverage_on_latlong_grid,
                        latlong_grid,
                        circle_radii_array,
                        number_of_circles,
                        fitness_function_selector,
                        ideal_circle_coverage_count_on_grid,
                        polygon_coverage_on_cartesian_grid);


                    if (fittest_record_found4 != null || fittest_record_found4.length != 0) {
                        fittest_record_found = fittest_record_found4[0];
                    }


                    all_ga_results_array[all_ga_results_array_index] = fittest_record_found;
                    all_ga_results_array_index++;

                }

                var sorted_all_ga_results_array = Sort_Generation_Result_Table(all_ga_results_array);

                var final_fittest_record_found = Evaluate_FitnessValue_Of_Tieing_Toppers(
                    sorted_all_ga_results_array, //toppers_generation_table
                    map,
                    polygon,
                    polygon_coverage_on_latlong_grid,
                    latlong_grid,
                    circle_radii_array,
                    ideal_circle_coverage_count_on_grid,
                    outside_covg_filter_selector);



                //var final_toppers_generation = [];
                //var final_toppers_generation_index = 0;

                //for (var i = 0; i < all_ga_results_array.length; i++) {

                //    if (all_ga_results_array[i][8] == 0) {

                //        final_toppers_generation[final_toppers_generation_index] = all_ga_results_array[i];

                //    }
                    
                //}




                if (hand_drawn_polygon_by_user == null) {
                    draw_polygon(polygon_selector);
                }

                if (hand_drawn_polygon_by_user != null) {
                    var polygon_symbol = new SimpleFillSymbol().setColor(null).outline.setColor("red").setWidth(3);
                    var polygon_graphic = new esri.Graphic(hand_drawn_polygon_by_user, polygon_symbol, { keeper: true });
                    graphics_layer.add(polygon_graphic);
                }


                show_record_on_map(
                    graphics_layer,
                    final_fittest_record_found,
                    latlong_grid,
                    final_fittest_record_found[10],// circle_radii_array
                    final_fittest_record_found[9]); //number_of_circles

                var endTime = performance.now();

                //show_record_on_map(graphics_layer, master_record[3][0], latlong_grid, radius_of_circle_in_meters);

                var total_polygon_points_covered_on_grid = polygon_coverage_on_cartesian_grid.length;
                var total_polygon_points_covered_by_circles = final_fittest_record_found[2];// FV

                var fittest_fitness_value = final_fittest_record_found[0];// FV
                var fittest_inside_covg_without_overlapping = final_fittest_record_found[2];// coverage without overlapping
                var fittest_inside_covg_with_overlapping = final_fittest_record_found[3];// coverage with overlapping
                var fittest_total_overlapping = final_fittest_record_found[4];// total overlapping
                var fittest_outside_covg = final_fittest_record_found[5];// circle outside coverage

                var text_offset_value_x = 6000;
                var text_offset_value_y = -700;

                var font = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol = new TextSymbol("Fitness Value : " + fittest_fitness_value, font, "blue");
                var labelPointGraphic = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 0 * text_offset_value_y), textSymbol);
                graphics_layer.add(labelPointGraphic);



                var polygon_percent_coverage = (total_polygon_points_covered_by_circles / total_polygon_points_covered_on_grid) * 100;
                polygon_percent_coverage = polygon_percent_coverage.toFixed(2);
                var font6 = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol6 = new TextSymbol("Circle Coverage : " + fittest_inside_covg_without_overlapping + " / " + total_polygon_points_covered_on_grid + " ( " + polygon_percent_coverage + "% )", font6, "blue");
                var labelPointGraphic6 = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 1 * text_offset_value_y), textSymbol6);
                graphics_layer.add(labelPointGraphic6);



                var elapsed_algo_time = (((endTime - startTime).toFixed(0)) / 1000);
                var font2 = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol2 = new TextSymbol("Time : " + elapsed_algo_time + "sec", font2, "blue");
                var labelPointGraphic2 = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 2 * text_offset_value_y), textSymbol2);
                graphics_layer.add(labelPointGraphic2);


                var circle_percent_coverage = (fittest_inside_covg_with_overlapping / ideal_circle_coverage_count_on_grid) * 100;
                circle_percent_coverage = circle_percent_coverage.toFixed(2);
                var font3 = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol3 = new TextSymbol("Circles Parts Used : " + fittest_inside_covg_with_overlapping + " / " + ideal_circle_coverage_count_on_grid + " ( " + circle_percent_coverage + "% )", font3, "blue");
                var labelPointGraphic3 = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 3 * text_offset_value_y), textSymbol3);
                graphics_layer.add(labelPointGraphic3);


                // Ideal Coverage - inside coverage with overlapping
                var circle_percent_outside_coverage = ((ideal_circle_coverage_count_on_grid - fittest_inside_covg_with_overlapping) / ideal_circle_coverage_count_on_grid) * 100;
                circle_percent_outside_coverage = circle_percent_outside_coverage.toFixed(2);
                var font4 = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol4 = new TextSymbol("Circles Parts Not Used : " + (ideal_circle_coverage_count_on_grid - fittest_inside_covg_with_overlapping) + " / " + ideal_circle_coverage_count_on_grid + " ( " + circle_percent_outside_coverage + "% )", font4, "blue");
                var labelPointGraphic4 = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 4 * text_offset_value_y), textSymbol4);
                graphics_layer.add(labelPointGraphic4);


                var font7 = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol7 = new TextSymbol("Inside Covg with Overlapping : " + fittest_inside_covg_with_overlapping, font7, "blue");
                var labelPointGraphic7 = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 5 * text_offset_value_y), textSymbol7);
                graphics_layer.add(labelPointGraphic7);


                var font8 = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol8 = new TextSymbol("Inside Covg without Overlapping : " + fittest_inside_covg_without_overlapping, font8, "blue");
                var labelPointGraphic8 = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 6 * text_offset_value_y), textSymbol8);
                graphics_layer.add(labelPointGraphic8);


                var font5 = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol5 = new TextSymbol("Overlapping : " + fittest_total_overlapping, font5, "blue");
                var labelPointGraphic5 = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 7 * text_offset_value_y), textSymbol5);
                graphics_layer.add(labelPointGraphic5);



                var font9 = Font("20", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                var textSymbol9 = new TextSymbol("Outside Covg : " + fittest_outside_covg, font9, "blue");
                var labelPointGraphic9 = new Graphic(latlong_grid[((grid_length - 1))][grid_length - 1].offset(text_offset_value_x, 8 * text_offset_value_y), textSymbol9);
                graphics_layer.add(labelPointGraphic9);



                //alert(latlong_grid[7][7]);
                return;

                Clear_Map();
                // called just show the record on grid, otherwise fitness value calculated above
                var FitnessValue = FindFitnessValueOfRecord_With_GridDrawings(master_record[3][0][1]);
                document.getElementById('divFitnessValue').innerHTML = "FitnessValue: " + FitnessValue + " <br /> Elapsed time: " + (endTime - startTime) + "ms";
                document.getElementById('divSeedAlgo').innerHTML = "Seed = Random & Cross Over = Binary";



                //get center point lat long form latlong grid
                var lat_long = Map_Cartesian_Point_To_LatLong_Point(index_grid[5][5], lat_long_grid);

                // create point form lat long
                var point = new esri.geometry.Point({ "x": lat_long[0], "y": lat_long[1], "spatialReference": map.spatialReference });

                // get the center point of polygon
                var center_point = polygon_drawings_results[0].getExtent().getCenter();

                // draw circle on center point
                var circle_drawings_results = draw_circle(graphics_layer, center_point, "blue", null);

                // get top righ corner of the latlong grid & show on map
                lat_long = Map_Cartesian_Point_To_LatLong_Point(index_grid[10][10], lat_long_grid);
                console.log(("xmax grid " + lat_long[0]));
                console.log(("ymax grid " + lat_long[1]));

                // get bottom left corner of the latlong grid & show on map
                lat_long = Map_Cartesian_Point_To_LatLong_Point(index_grid[0][0], lat_long_grid);
                console.log(("xmin grid " + lat_long[0]));
                console.log(("ymin grid " + lat_long[1]));

                alert("Circle contains point " + circle_drawings_results[0].contains(point));
                alert("Polygon contains point " + polygon_drawings_results[0].contains(point));


            }




            function Remove_Eclipsed_Circles_From_Fittest_Record(
                fittest_record_found,
                circle_radii_array) {

                var fittest_centre_points_found = fittest_record_found[1];
                var eclipsed_circles_in_polygon = fittest_record_found[7];

                var result = [];

                var new_circle_radii_array = [];
                var new_centre_points_for_record = [];
                var new_centre_points_for_record_index = 0;
                var found_flag = false;

                for (var i = 0; i < fittest_centre_points_found.length; i++) {

                    found_flag = false;

                    for (var j = 0; j < eclipsed_circles_in_polygon.length; j++) {

                        if (i == eclipsed_circles_in_polygon[j]) {
                            found_flag = true;
                            break;
                        }

                    }

                    if (!found_flag) {
                        new_centre_points_for_record[new_centre_points_for_record_index] = fittest_centre_points_found[i];
                        new_circle_radii_array[new_centre_points_for_record_index] = circle_radii_array[i];
                        new_centre_points_for_record_index++;
                    }
                }

                result[0] = [];
                result[0][0] = new_centre_points_for_record;
                result[1] = new_circle_radii_array;

                return result;

            }



            function Consider_Missing_Points_N_Create_Generation(fittest_record_found) {

                var fittest_centre_points_found = fittest_record_found[1];
                var missing_points_in_polygon = fittest_record_found[6];

                var new_cartesian_generation = [];
                var new_cartesian_generation_index = 1;

                new_cartesian_generation[0] = fittest_record_found[1];

                for (var i = 0; i < missing_points_in_polygon.length; i++) {

                    for (var j = 0; j < fittest_centre_points_found.length; j++) {

                        var new_record = [];

                        for (var k = 0; k < fittest_centre_points_found.length; k++) {
                            new_record[k] = fittest_centre_points_found[k];
                        }

                        new_record[j] = missing_points_in_polygon[i];
                        new_cartesian_generation[new_cartesian_generation_index] = new_record;
                        new_cartesian_generation_index++;
                    }

                }

                return new_cartesian_generation;


            }


            function Repair_Fittest_Record_N_Create_Generation(fittest_record_found) {

                //alert("reparing");

                var fittest_centre_points_found = fittest_record_found[1];
                var all_center_combinations = permute(fittest_centre_points_found.length);
                var repaired_cartesian_generation = [];
                var repaired_cartesian_generation_index = 0;

                for (var i = 0; i < all_center_combinations.length; i++) {

                    var new_record = [];

                    for (var j = 0; j < all_center_combinations[i].length; j++) {

                        new_record[j] = fittest_centre_points_found[all_center_combinations[i][j]]

                    }

                    repaired_cartesian_generation[repaired_cartesian_generation_index] = new_record;
                    repaired_cartesian_generation_index++;
                }

                //alert("out of reparing");

                return repaired_cartesian_generation;


            }



            //var fittest_record_found = Evaluate_FitnessValue_Of_Tieing_Toppers(
            //    master_record[3],
            //    map,
            //    polygon,
            //    polygon_coverage_on_latlong_grid,
            //    latlong_grid);


            function Evaluate_FitnessValue_Of_Tieing_Toppers(
                toppers_generation_table,
                map,
                polygon,
                polygon_coverage_on_latlong_grid,
                latlong_grid,
                circle_radii_array,
                ideal_circle_coverage_count_on_grid,
                outside_covg_filter_selector) {

                // passed value is master_record[3]

                var fittest_record = [];
                var top_fitness_value = toppers_generation_table[0][0];

                var tieing_toppers_records = [];
                var index = 0;

                // get the list of tieing toppers records with same fitness value
                for (var i = 0; i < toppers_generation_table.length; i++) {

                    if (toppers_generation_table[i][0] == top_fitness_value) {
                        tieing_toppers_records[index] = toppers_generation_table[i];
                        index++;
                    }
                    else {
                        // because records are sorteed
                        break;
                    }

                }

                // if only one record, no tieing fitness value records, then retrun that record
                if (tieing_toppers_records.length == 1) {
                    return toppers_generation_table[0];
                }



                var lowest_outside_circle_coverage = 9999999;
                var lowest_outside_circle_coverage_index = -1;

                // loop through tieing toppers records and find records with
                // min outside coverage
                for (var i = 0; i < tieing_toppers_records.length; i++) {

                    //var tieing_topper_fitness_value = tieing_toppers_records[i][0];

                    // Find overlapping among circles within polygon
                    // it is not complete overlapping among circles
                    // it is only overlapping within polygon, not outside polygon
                    // Inside coverage with overlapping
                    var tieing_topper_fitness_value_with_overlapping = tieing_toppers_records[i][3];

                    // get the record having multiple circels centerpoints
                    var tieing_topper_record = tieing_toppers_records[i][1];

                    var tieing_topper_outside_circle_coverage;
                    if (outside_covg_filter_selector == 1) {

                        // Old solution agreed with adnan
                        tieing_topper_outside_circle_coverage = Get_Circle_Outside_Coverage_Of_Record_Map(
                            tieing_topper_record,
                            map,
                            polygon,
                            polygon_coverage_on_latlong_grid,
                            latlong_grid,
                            circle_radii_array);
                    }
                    else {
                        // Asif sb solution
                        //tieing_topper_outside_circle_coverage =
                        //    ideal_circle_coverage_count_on_grid - tieing_topper_fitness_value_with_overlapping;

                        tieing_topper_outside_circle_coverage = tieing_toppers_records[i][5];

                    }

                    //alert("tieing_topper_outside_circle_coverage-A" + tieing_topper_outside_circle_coverage);

                    //var tieing_topper_outside_circle_coverage = tieing_toppers_records[i][5];

                    //alert("tieing_topper_outside_circle_coverage-B" + tieing_topper_outside_circle_coverage22);

                    // Step1: Select Records with least overlapping inside polygon
                    // Step2: Now Select the Record having maximum overlapping inside the polygon.
                    if (tieing_topper_outside_circle_coverage < lowest_outside_circle_coverage) {
                        lowest_outside_circle_coverage = tieing_topper_outside_circle_coverage;
                        lowest_outside_circle_coverage_index = i;
                    }

                }


                return tieing_toppers_records[lowest_outside_circle_coverage_index];


            }


            function Evaluate_FitnessValue_Of_Seed_Generation_Return_All_Records_GIS(
                cartesian_generation,
                map,
                polygon,
                polygon_coverage, //polygon_coverage_on_latlong_grid
                latlong_grid,
                circle_radii_array,
                number_of_circles,
                fitness_function_selector,
                ideal_circle_coverage_count_on_grid,
                polygon_coverage_on_cartesian_grid) {

                var Generation_Result_Table = [];// result of generation with fitness value
                var maxfitnessvalue = -1;
                var maxfitnessvalueindex = -1
                var maxfitnessvaluerecord = null;
                var record;
                var FitnessValue;
                var FitnessValue_with_Overlapping;

                var latlong_generation = Map_Cartesian_Generation_To_LatLong_Generation(
                    cartesian_generation,
                    latlong_grid,
                    number_of_circles);

                for (var i = 0; i < latlong_generation.length; i++) {

                    // lat long record
                    record = latlong_generation[i];

                    //console.log("Evaluating Record " + (i + 1));
                    //console.log("Record Values ");
                    //print_point_array_to_console(record);


                    var coverage_results_with_n_without = Get_FitnessValue_Of_Record_Map(
                        record, // lat long record
                        map,
                        polygon,
                        polygon_coverage, //polygon_coverage_on_latlong_grid
                        latlong_grid,
                        circle_radii_array,
                        number_of_circles,
                        fitness_function_selector,
                        ideal_circle_coverage_count_on_grid,
                        polygon_coverage_on_cartesian_grid);


                    FitnessValue = coverage_results_with_n_without[0];// fitness value
                    FitnessValue_with_Overlapping = coverage_results_with_n_without[1];

                    //console.log("Record " + (i + 1) + " Fitness Value " + FitnessValue);

                    if (FitnessValue > maxfitnessvalue) {

                        maxfitnessvalue = FitnessValue;
                        maxfitnessvalueindex = i;
                        maxfitnessvaluerecord = cartesian_generation[i];
                    }


                    var Record_Result = [];
                    Record_Result[0] = coverage_results_with_n_without[0]; // FV
                    Record_Result[1] = cartesian_generation[i]; // save cartesian record
                    Record_Result[2] = coverage_results_with_n_without[1]; // FV without overlapping
                    Record_Result[3] = coverage_results_with_n_without[2]; // FV with overlapping
                    Record_Result[4] = coverage_results_with_n_without[3]; // total overlapping
                    Record_Result[5] = coverage_results_with_n_without[4]; // circle outside coverage
                    Record_Result[6] = coverage_results_with_n_without[5]; //  polygon_not_covered_points
                    Record_Result[7] = coverage_results_with_n_without[6]; //  eclipsed_circles_array
                    Record_Result[8] = coverage_results_with_n_without[7]; //  not covered points count
                    Record_Result[9] = coverage_results_with_n_without[8]; //  number_of_circles
                    Record_Result[10] = coverage_results_with_n_without[9]; //  circle_radii_array


                    Generation_Result_Table[i] = Record_Result;

                }

                // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                console.log("Initial Seed Generation Results");
                Print_Generation_Result_Table(Generation_Result_Table);
                console.log("===============");

                var Sorted_Generation_Result_Table = Sort_Generation_Result_Table(Generation_Result_Table);


                // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                console.log("Sorted Initial Seed Generation Results");
                Print_Generation_Result_Table(Sorted_Generation_Result_Table);
                console.log("===============");

                return Sorted_Generation_Result_Table;


            }



            function GENETIC_ALGO_To_Evaluate_FitnessValue_Of_Generation_With_Binary_CrossOver_Map(
                iteration_count, //1
                top_records_list, //2
                prev_gen_record_list, //3
                all_records_list, //4
                cartesian_generation, //5
                map, //6
                polygon, //7
                polygon_coverage_on_latlong_grid, //8
                polygon_coverage_on_cartesian_grid, //9
                latlong_grid, //10
                number_of_top_records_goto_to_next_generation, //11
                number_of_records_in_each_crossover_generations, //12
                number_of_crossovers_before_mutations, //13
                required_coverage, //14
                radius_of_circle_in_meters
            ) {

                //console.log("top 4 records after random generation evaluation");
                //Print_Generation_Result_Table(top4_records_list);
                //console.log("top record after random generation  evaluation ");
                //Print_Generation_Result_Table(top_records_list);

                var Generation_Result_Table = [];// result of generation with fitness value
                var maxfitnessvalue = -99999999999;
                var maxfitnessvalueindex = -1
                var maxfitnessvaluerecord = null;
                var record;
                var FitnessValue;


                // Binary Cross Over takes 4 values and return 8 values
                var topper_of_previous_generation = [];


                if (prev_gen_record_list == null || prev_gen_record_list.length <= 0) {

                    // Case Ist Iteration
                    if (all_records_list == null || all_records_list.length <= 0) {
                        alert("All Records List Found Null Iteration " + iteration_count);
                    }

                    //for (var i = 0; i < all_records_list.length; i++) {
                    //    topper_of_previous_generation[i] = all_records_list[i][1];
                    //}

                    topper_of_previous_generation[0] = all_records_list[0][1];
                    topper_of_previous_generation[1] = all_records_list[1][1];
                    topper_of_previous_generation[2] = all_records_list[2][1];
                    topper_of_previous_generation[3] = all_records_list[3][1];
                }
                else {


                    //var counter = 0;

                    //if (prev_gen_record_list.length > 4) {
                    //    counter = 4;
                    //}
                    //else {
                    //    counter = prev_gen_record_list.length;
                    //}


                    for (var i = 0; i < prev_gen_record_list.length; i++) {
                        topper_of_previous_generation[i] = prev_gen_record_list[i][1];
                    }

                    //topper_of_previous_generation[0] = prev_gen_record_list[0][1];
                    //topper_of_previous_generation[1] = prev_gen_record_list[1][1];
                    //topper_of_previous_generation[2] = prev_gen_record_list[2][1];
                    //topper_of_previous_generation[3] = prev_gen_record_list[3][1];
                }

                //topper_of_previous_generation[0] = top4_records_list[top4_records_list.length - 4][1];
                //topper_of_previous_generation[1] = top4_records_list[top4_records_list.length - 3][1];
                //topper_of_previous_generation[2] = top4_records_list[top4_records_list.length - 2][1];
                //topper_of_previous_generation[3] = top4_records_list[top4_records_list.length - 1][1];

                console.log("===============");
                console.log("Iteration [" + [iteration_count + 1] + "] Top 4 Records before Binary Cross-Over ");
                Print_Generation(topper_of_previous_generation);
                console.log("===============");


                // Binary Cross Over takes 4 Records and return 8 Records
                var generation = Crossover_Generation_On_Map(
                    topper_of_previous_generation, //1
                    polygon_coverage_on_cartesian_grid, //2
                    latlong_grid.length, //3
                    number_of_records_in_each_crossover_generations //4
                );

                // Get latlong_generation
                var latlong_generation = Map_Cartesian_Generation_To_LatLong_Generation(generation, latlong_grid);

                // Print New Generation
                console.log("Iteration [" + [iteration_count + 1] + "] New Generation after Binary Cross-Over ");
                Print_Generation(generation);
                console.log("===============");


                // Hold topper fitness record during evaluation
                var Top_Record_Result = [];
                Top_Record_Result[0] = [];


                for (var i = 0; i < latlong_generation.length; i++) {

                    var record = latlong_generation[i];

                    //console.log("Evaluating Record " + i);
                    //console.log("Record Values " + record);

                    var FitnessValue = Get_FitnessValue_Of_Record_Map(
                        record,
                        map,
                        polygon,
                        polygon_coverage_on_latlong_grid,
                        latlong_grid,
                        radius_of_circle_in_meters
                    );

                    //console.log("Record " + (i + 1) + " Fitness Value " + FitnessValue);

                    if (FitnessValue > maxfitnessvalue) {

                        maxfitnessvalue = FitnessValue;
                        maxfitnessvalueindex = i;
                        maxfitnessvaluerecord = generation[i];

                        Top_Record_Result[0][0] = FitnessValue;
                        Top_Record_Result[0][1] = generation[i];

                    }

                    var Record_Result = [];
                    Record_Result[0] = FitnessValue;
                    Record_Result[1] = generation[i];

                    Generation_Result_Table[i] = Record_Result;

                }

                console.log("Iteration [" + [iteration_count + 1] + "] Binary Cross Over Generation results");
                Print_Generation_Result_Table(Generation_Result_Table);
                console.log("===============");


                //var Generation_Top4_Result_Table = Sort_Generation_Result_Table_Return_Top4_Records(Generation_Result_Table);

                // following sort will eliminate duplicate records present in the table
                // duplication means same Fitness Value & Points, all such points will be removed
                var Generation_Top4_Result_Table = Sort_Generation_Result_Table(Generation_Result_Table);

                //console.log("===============");
                console.log("Iteration [" + [iteration_count + 1] + "] Sorted Binary Cross Over Generation results");
                Print_Generation_Result_Table(Generation_Top4_Result_Table);
                console.log("===============");

                var r1 = Merge_Generation_Result_Tables(all_records_list, Generation_Top4_Result_Table);
                // following sort will eliminate duplicate records present in the table
                // duplication means same Fitness Value & Points, all such points will be removed
                var sortedr1 = Sort_Generation_Result_Table(r1);
                console.log("Iteration [" + [iteration_count + 1] + "] Detailed Fitness Value Result Table Up-To-Now");
                console.log("===============");
                Print_Generation_Result_Table(sortedr1);


                var r2 = Merge_Generation_Result_Tables(top_records_list, Top_Record_Result);
                // following sort will eliminate duplicate records present in the table
                // duplication means same Fitness Value & Points, all such points will be removed
                var sortedr2 = Sort_Generation_Result_Table(r2);
                console.log("Iteration [" + [iteration_count + 1] + "] Iteration Top Fitness Value Results Table Up-To-Now");
                console.log("===============");
                Print_Generation_Result_Table(sortedr2);


                var master_record = [];

                master_record[0] = Generation_Top4_Result_Table;// sorted generation table of this iteration
                master_record[1] = Top_Record_Result;// topper of this iteration
                master_record[2] = sortedr1; // sorted generation table of all iterations
                master_record[3] = sortedr2; // sorted generation table of TOPPERS all iterations

                return master_record;
                //master_record[3][0][1] // this record to show on screen
                //return sortedr2[0][1];
            }




            function GENETIC_ALGO_To_Evaluate_FitnessValue_Of_Generation_With_Binary_CrossOver_Map_Configurable(
                iteration_count, //1
                top_records_list, //2
                prev_gen_record_list, //3
                all_records_list, //4
                cartesian_generation, //5
                map, //6
                polygon, //7
                polygon_coverage_on_latlong_grid, //8
                polygon_coverage_on_cartesian_grid, //9
                latlong_grid, //10
                number_of_top_records_goto_to_next_generation, //11
                number_of_records_in_each_crossover_generations, //12
                number_of_crossovers_before_mutations, //13
                required_coverage, //14
                circle_radii_array,
                number_of_circles,
                fitness_function_selector,
                ideal_circle_coverage_count_on_grid
            ) {

                var Generation_Result_Table = [];// result of generation with fitness value
                var maxfitnessvalue = -99999999999;
                var maxfitnessvalueindex = -1
                var maxfitnessvaluerecord = null;
                var record;
                var FitnessValue;
                var FitnessValue_with_Overlapping;

                // Binary Cross Over takes any number of values and return any number of values
                var topper_of_previous_generation = [];

                if (prev_gen_record_list == null || prev_gen_record_list.length <= 0) {

                    // Case Ist Iteration
                    if (all_records_list == null || all_records_list.length <= 0) {
                        alert("All Records List Found Null Iteration " + iteration_count);
                    }

                    for (var i = 0; i < number_of_top_records_goto_to_next_generation; i++) {
                        topper_of_previous_generation[i] = all_records_list[i][1];
                    }

                }
                else {
                    for (var i = 0; i < number_of_top_records_goto_to_next_generation; i++) {
                        topper_of_previous_generation[i] = prev_gen_record_list[i][1];// 2nd value of array
                    }
                }

                // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                console.log("===============");
                console.error("Iteration [" + [iteration_count + 1] + "] Top " + number_of_top_records_goto_to_next_generation + " Records before Binary Cross-Over ");
                Print_Generation(topper_of_previous_generation);
                console.log("===============");


                // Binary Cross Over takes any no of records and return any no of records
                // Returns a Cartesian Generation
                var generation = Crossover_Generation_On_Map_Configurable(
                    topper_of_previous_generation, //1
                    polygon_coverage_on_cartesian_grid, //2
                    latlong_grid.length, //3
                    number_of_records_in_each_crossover_generations //4
                );


                // Convert Cartesian Generation to Lat Long Generation
                var latlong_generation = Map_Cartesian_Generation_To_LatLong_Generation(
                    generation,
                    latlong_grid,
                    number_of_circles);


                // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                console.log("Iteration [" + [iteration_count + 1] + "] New Generation after Binary Cross-Over ");
                Print_Generation(generation);
                console.log("===============");


                var Top_Record_Result = [];
                Top_Record_Result[0] = [];


                for (var i = 0; i < latlong_generation.length; i++) {

                    // lat long record
                    var record = latlong_generation[i];

                    //console.log("Evaluating Record " + i);
                    //console.log("Record Values " + record);

                    var coverage_results_with_n_without = Get_FitnessValue_Of_Record_Map(
                        record, // lat long record
                        map,
                        polygon,
                        polygon_coverage_on_latlong_grid,
                        latlong_grid,
                        circle_radii_array,
                        number_of_circles,
                        fitness_function_selector,
                        ideal_circle_coverage_count_on_grid,
                        polygon_coverage_on_cartesian_grid);

                    FitnessValue = coverage_results_with_n_without[0];// FV
                    FitnessValue_with_Overlapping = coverage_results_with_n_without[1]; //without overlapping

                    //console.log("Record " + (i + 1) + " Fitness Value " + FitnessValue);

                    if (FitnessValue > maxfitnessvalue) {

                        maxfitnessvalue = FitnessValue;
                        maxfitnessvalueindex = i;
                        maxfitnessvaluerecord = generation[i];

                        // Saving topper cartesian records of generation
                        Top_Record_Result[0][0] = coverage_results_with_n_without[0]; // FV
                        Top_Record_Result[0][1] = generation[i]; // Cartesoam Recprd
                        Top_Record_Result[0][2] = coverage_results_with_n_without[1]; // FV without overlapping
                        Top_Record_Result[0][3] = coverage_results_with_n_without[2]; // FV with overlapping
                        Top_Record_Result[0][4] = coverage_results_with_n_without[3]; // total overlapping
                        Top_Record_Result[0][5] = coverage_results_with_n_without[4]; // circle outside coverage
                        Top_Record_Result[0][6] = coverage_results_with_n_without[5]; //  polygon_not_covered_points
                        Top_Record_Result[0][7] = coverage_results_with_n_without[6]; //  eclipsed_circles_array
                        Top_Record_Result[0][8] = coverage_results_with_n_without[7]; //  not covered points count
                        Top_Record_Result[0][9] = coverage_results_with_n_without[8]; //  number_of_circles
                        Top_Record_Result[0][10] = coverage_results_with_n_without[9]; //  circle_radii_array
                    }


                    // Saving generation result
                    var Record_Result = [];
                    Record_Result[0] = coverage_results_with_n_without[0]; // FV
                    Record_Result[1] = generation[i];// save cartesian record
                    Record_Result[2] = coverage_results_with_n_without[1]; // FV without overlapping
                    Record_Result[3] = coverage_results_with_n_without[2]; // FV with overlapping
                    Record_Result[4] = coverage_results_with_n_without[3]; // total overlapping
                    Record_Result[5] = coverage_results_with_n_without[4]; // circle outside coverage
                    Record_Result[6] = coverage_results_with_n_without[5]; //  polygon_not_covered_points
                    Record_Result[7] = coverage_results_with_n_without[6]; //  eclipsed_circles_array
                    Record_Result[8] = coverage_results_with_n_without[7]; //  not covered points count
                    Record_Result[9] = coverage_results_with_n_without[8]; //  number_of_circles
                    Record_Result[10] = coverage_results_with_n_without[9]; //  circle_radii_array

                    Generation_Result_Table[i] = Record_Result;

                }

                // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                //Printing unsorted generation results
                console.log("Iteration [" + [iteration_count + 1] + "] Binary Cross Over Generation results");
                Print_Generation_Result_Table(Generation_Result_Table);
                console.log("===============");


                // following sort will eliminate duplicate records present in the table
                // duplication means same Fitness Value & Points, all such points will be removed
                var Generation_Sorted_Result_Table = Sort_Generation_Result_Table(Generation_Result_Table);



                // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                console.log("Iteration [" + [iteration_count + 1] + "] Sorted Binary Cross Over Generation results");
                Print_Generation_Result_Table(Generation_Sorted_Result_Table);
                console.log("===============");


                //console.error("all_records_listnnnnnnnnnnnn" + all_records_list.length);
                //console.error("Generation_Sorted_Result_Tablennnnnnnnnnnnnnnn" + Generation_Sorted_Result_Table.length);



                // No need to maintain this master list
                //var Master_Result_Table = Merge_Generation_Result_Tables(all_records_list, Generation_Sorted_Result_Table);



                //console.log("Iteration [" + [iteration_count + 1] + "] WITHOUT SORTINGuuuuuuuuuuuuuuuuuuuuuuu");
                //console.log("===============");
                //Print_Generation_Result_Table(Master_Result_Table);

                // No need to maintain this master list
                // following sort will eliminate duplicate records present in the table
                // duplication means same Fitness Value & Points, all such points will be removed
                //var Sorted_Master_Result_Table = Sort_Generation_Result_Table(Master_Result_Table);
                //console.log("Iteration [" + [iteration_count + 1] + "] Detailed Fitness Value Result Table Up-To-Now");
                //console.log("===============");
                //Print_Generation_Result_Table(Sorted_Master_Result_Table);

                //console.error("Master_Result_Table" + Master_Result_Table.length);
                //console.error("Sorted_Master_Result_Table" + Sorted_Master_Result_Table.length);

                var Toppers_Result_Table = Merge_Generation_Result_Tables(top_records_list, Top_Record_Result);
                // following sort will eliminate duplicate records present in the table
                // duplication means same Fitness Value & Points, all such points will be removed
                var Sorted_Toppers_Result_Table = Sort_Generation_Result_Table(Toppers_Result_Table);

                // Needed only for debugging @@@@@@@@@@@@@@@@@@@@@@@@@@
                console.log("Iteration [" + [iteration_count + 1] + "] Topper Fitness Value Results Table Up-To-Now");
                console.log("===============");
                Print_Generation_Result_Table(Sorted_Toppers_Result_Table);

                var master_record = [];

                master_record[0] = Generation_Sorted_Result_Table;// sorted generation table of this iteration
                master_record[1] = Top_Record_Result;// topper of this iteration

                master_record[2] = null; // No need to maintain this master list
                //master_record[2] = Sorted_Master_Result_Table; // sorted generation table of all iterations
                master_record[3] = Sorted_Toppers_Result_Table; // sorted generation table of TOPPERS all iterations

                return master_record;
                //master_record[3][0][1] // this record to show on screen
                //return sortedr2[0][1];

            }





            function Get_FitnessValue_Of_Record_Map(
                record, // lat long record
                map,
                polygon,
                polygon_coverage, //polygon_coverage_on_latlong_grid
                latlong_grid,
                circle_radii_array,
                number_of_circles,
                fitness_function_selector,
                ideal_circle_coverage_count_on_grid,
                polygon_coverage_on_cartesian_grid) {


                var center_point = [];
                for (var i = 0; i < record.length; i++) {
                    center_point[i] = record[i];
                }

                var duplicate_polygon_coverage = [];
                for (var i = 0; i < polygon_coverage_on_cartesian_grid.length; i++) {
                    duplicate_polygon_coverage[i] = polygon_coverage_on_cartesian_grid[i];
                }


                //var center_point_1 = record[0]; //new esri.geometry.Point({ "x": record[0][0], "y": record[0][1], "spatialReference": map.spatialReference });
                //var center_point_2 = record[1]; //new esri.geometry.Point({ "x": record[1][0], "y": record[1][1], "spatialReference": map.spatialReference });
                //var center_point_3 = record[2]; //new esri.geometry.Point({ "x": record[2][0], "y": record[2][1], "spatialReference": map.spatialReference });
                //var center_point_4 = record[3]; //new esri.geometry.Point({ "x": record[3][0], "y": record[3][1], "spatialReference": map.spatialReference });


                var circle_polygon = [];
                for (var i = 0; i < center_point.length; i++) {
                    circle_polygon[i] = get_circle_polygon(center_point[i], circle_radii_array[i]);
                }


                //var circle_polygon_1 = get_circle_polygon(center_point_1, radius_of_circle_in_meters);
                //var circle_polygon_2 = get_circle_polygon(center_point_2, radius_of_circle_in_meters);
                //var circle_polygon_3 = get_circle_polygon(center_point_3, radius_of_circle_in_meters);
                //var circle_polygon_4 = get_circle_polygon(center_point_4, radius_of_circle_in_meters);


                // circle coverge points count inside polygon
                var cir_cov_ins_poly = [];
                for (var i = 0; i < circle_polygon.length; i++) {
                    cir_cov_ins_poly[i] = get_circle_coverage_inside_polygon(circle_polygon[i], polygon_coverage);
                }


                // circle coverge points count inside polygon
                //var cir_cov_ins_poly_1 = get_circle_coverage_inside_polygon(circle_polygon_1, polygon_coverage);
                //var cir_cov_ins_poly_2 = get_circle_coverage_inside_polygon(circle_polygon_2, polygon_coverage);
                //var cir_cov_ins_poly_3 = get_circle_coverage_inside_polygon(circle_polygon_3, polygon_coverage);
                //var cir_cov_ins_poly_4 = get_circle_coverage_inside_polygon(circle_polygon_4, polygon_coverage);


                var total_cir_cov_ins_poly_with_overlapping = 0;

                for (var i = 0; i < cir_cov_ins_poly.length; i++) {
                    total_cir_cov_ins_poly_with_overlapping = total_cir_cov_ins_poly_with_overlapping + cir_cov_ins_poly[i];
                }


                //var total_cir_cov_ins_poly_with_overlapping = cir_cov_ins_poly_1 + cir_cov_ins_poly_2 + cir_cov_ins_poly_3 + cir_cov_ins_poly_4;

                //console.log("circle 1 coverage inside polygon " + cir_cov_ins_poly_1);
                //console.log("circle 2 coverage inside polygon " + cir_cov_ins_poly_2);
                //console.log("circle 3 coverage inside polygon " + cir_cov_ins_poly_3);
                //console.log("circle 4 coverage inside polygon " + cir_cov_ins_poly_4);
                //console.log("total circle coverage inside polygon with overlapping " + total_cir_cov_ins_poly_with_overlapping);

                // Ref 1:
                // circle coverge points array inside polygon
                var cir_cov_pts_ins_poly = [];
                for (var i = 0; i < circle_polygon.length; i++) {

                    cir_cov_pts_ins_poly[i] = get_circle_coverage_points_inside_polygon(
                        circle_polygon[i],
                        polygon_coverage,
                        duplicate_polygon_coverage);

                }

                var polygon_not_covered_points = [];
                var polygon_not_covered_points_index = 0;

                for (var i = 0; i < duplicate_polygon_coverage.length; i++) {

                    if (duplicate_polygon_coverage[i] != null) {
                        polygon_not_covered_points[polygon_not_covered_points_index] = duplicate_polygon_coverage[i];
                        polygon_not_covered_points_index++;
                    }

                }


                // circle coverge points array inside polygon
                //var cir_cov_pts_ins_poly_1 = get_circle_coverage_points_inside_polygon(circle_polygon_1, polygon_coverage);
                //var cir_cov_pts_ins_poly_2 = get_circle_coverage_points_inside_polygon(circle_polygon_2, polygon_coverage);
                //var cir_cov_pts_ins_poly_3 = get_circle_coverage_points_inside_polygon(circle_polygon_3, polygon_coverage);
                //var cir_cov_pts_ins_poly_4 = get_circle_coverage_points_inside_polygon(circle_polygon_4, polygon_coverage);

                var total_overlapping_amongall_circles = 0;
                var total_overlapping_amongtwo_circles = 0;
                var eclipsed_circles_array = [];
                var eclipsed_circles_array_index = 0;


                for (var i = 0; i < number_of_circles - 1; i++) {

                    for (var j = i + 1; j < number_of_circles; j++) {

                        total_overlapping_amongtwo_circles = find_overlapping_between_circles(cir_cov_pts_ins_poly[i], cir_cov_pts_ins_poly[j]);

                        if (total_overlapping_amongtwo_circles >= cir_cov_pts_ins_poly[i].length) {
                            eclipsed_circles_array[eclipsed_circles_array_index] = i;
                            eclipsed_circles_array_index++;
                        }

                        if (total_overlapping_amongtwo_circles >= cir_cov_pts_ins_poly[j].length) {
                            eclipsed_circles_array[eclipsed_circles_array_index] = j;
                            eclipsed_circles_array_index++;
                        }

                        total_overlapping_amongall_circles = total_overlapping_amongall_circles + total_overlapping_amongtwo_circles;


                    }
                }



                // circle1 & circlec2 overlapping INSIDE polygon.
                // this overlapping does not involve overlapping outside polygon
                //var overlapping12 = find_overlapping_between_circles(cir_cov_pts_ins_poly_1, cir_cov_pts_ins_poly_2);
                //var overlapping13 = find_overlapping_between_circles(cir_cov_pts_ins_poly_1, cir_cov_pts_ins_poly_3);
                //var overlapping14 = find_overlapping_between_circles(cir_cov_pts_ins_poly_1, cir_cov_pts_ins_poly_4);
                //var overlapping23 = find_overlapping_between_circles(cir_cov_pts_ins_poly_2, cir_cov_pts_ins_poly_3);
                //var overlapping24 = find_overlapping_between_circles(cir_cov_pts_ins_poly_2, cir_cov_pts_ins_poly_4);
                //var overlapping34 = find_overlapping_between_circles(cir_cov_pts_ins_poly_3, cir_cov_pts_ins_poly_4);
                //var total_overlapping_amongall_circles = overlapping12 + overlapping13 + overlapping14 + overlapping23 + overlapping24 + overlapping34;


                //console.log("circle 1 & 2 overlappings " + overlapping12);
                //console.log("circle 1 & 3 overlappings " + overlapping13);
                //console.log("circle 1 & 4 overlappings " + overlapping14);
                //console.log("circle 2 & 3 overlappings " + overlapping23);
                //console.log("circle 2 & 4 overlappings " + overlapping24);
                //console.log("circle 3 & 4 overlappings " + overlapping34);
                //console.log("total overlappings " + total_overlapping_amongall_circles);

                // fitness value = inside covg count - inside overlapping
                var total_cir_cov_ins_poly_without_overlapping = total_cir_cov_ins_poly_with_overlapping - total_overlapping_amongall_circles;



                //*********************************************************************************************
                // ALL POINTS OF A CIRCLE LIE ON THE GRID.
                // IT DOES NOT COUNT THE PART OF CIRCLE GOING OUTSIDE GRID.
                // IT ONLY COUNTS THE PART OF CIRCLE LYING ON THE GIRD.
                //var cir_cov_on_grid = [];
                //for (var i = 0; i < circle_polygon.length; i++) {
                //    cir_cov_on_grid[i] = get_polygon_coverage_on_latlong_grid(circle_polygon[i], latlong_grid);
                //}


                // OLD CODE
                //var cir1_cov_on_grid = get_polygon_coverage_on_latlong_grid(circle_polygon_1, latlong_grid);
                //var cir2_cov_on_grid = get_polygon_coverage_on_latlong_grid(circle_polygon_2, latlong_grid);
                //var cir3_cov_on_grid = get_polygon_coverage_on_latlong_grid(circle_polygon_3, latlong_grid);
                //var cir4_cov_on_grid = get_polygon_coverage_on_latlong_grid(circle_polygon_4, latlong_grid);
                //console.log("circle 1 points on map ");
                //print_point_array_to_console(cir1_cov_on_grid);
                //console.log("circle 2 points on map");
                //print_point_array_to_console(cir2_cov_on_grid);
                //console.log("circle 3 points on map");
                //print_point_array_to_console(cir3_cov_on_grid);
                //console.log("circle 4 points on map");
                //print_point_array_to_console(cir4_cov_on_grid);


                // ALL POINTS OF A CIRCLE NOT LIE IN THE POLYGON.
                // IT DOES NOT COUNT THE PART OF CIRCLE GOING OUTSIDE GRID.
                // IT ONLY COUNTS THE PART OF CIRCLE LYING ON THE GIRD.
                //var total_cir_cov_outs_poly = 0;

                //for (var i = 0; i < cir_cov_ins_poly.length; i++) {
                //    total_cir_cov_outs_poly = total_cir_cov_outs_poly + get_circle_coverage_outside_polygon(polygon, cir_cov_on_grid[i]);
                //}


                // OLD CODE
                //var cir1_cov_outs_poly = get_circle_coverage_outside_polygon(polygon, cir1_cov_on_grid);
                //var cir2_cov_outs_poly = get_circle_coverage_outside_polygon(polygon, cir2_cov_on_grid);
                //var cir3_cov_outs_poly = get_circle_coverage_outside_polygon(polygon, cir3_cov_on_grid);
                //var cir4_cov_outs_poly = get_circle_coverage_outside_polygon(polygon, cir4_cov_on_grid);
                //var total_cir_cov_outs_poly = cir1_cov_outs_poly + cir2_cov_outs_poly + cir3_cov_outs_poly + cir4_cov_outs_poly;
                //console.log("circle 1 coverage outside polygon " + cir1_cov_outs_poly);
                //console.log("circle 2 coverage outside polygon " + cir2_cov_outs_poly);
                //console.log("circle 3 coverage outside polygon " + cir3_cov_outs_poly);
                //console.log("circle 4 coverage outside polygon " + cir4_cov_outs_poly);
                //console.log("total circles coverage outside polygon " + total_cir_cov_outs_poly);

                //******************************************************************************************

                var total_cir_cov_outs_poly = 0;
                total_cir_cov_outs_poly = ideal_circle_coverage_count_on_grid - total_cir_cov_ins_poly_with_overlapping;


                var coverage_results_with_n_without = [];
                var fv_formula;

                if (fitness_function_selector == 1) {
                    fv_formula = total_cir_cov_ins_poly_without_overlapping;
                }
                else if (fitness_function_selector == 2) {
                    fv_formula = (total_cir_cov_ins_poly_with_overlapping + (2 * total_cir_cov_ins_poly_without_overlapping)) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly);
                }
                else if (fitness_function_selector == 3) {
                    fv_formula = (total_cir_cov_ins_poly_with_overlapping + (3 * total_cir_cov_ins_poly_without_overlapping)) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly);
                }
                else if (fitness_function_selector == 4) {
                    fv_formula = (total_cir_cov_ins_poly_with_overlapping + (4 * total_cir_cov_ins_poly_without_overlapping)) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly);
                }
                else if (fitness_function_selector == 5) {
                    fv_formula = total_cir_cov_ins_poly_without_overlapping - total_cir_cov_outs_poly;
                }
                else if (fitness_function_selector == 6) {
                    fv_formula = 2 * (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_ins_poly_without_overlapping) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly);
                }
                else {
                    fv_formula = total_cir_cov_ins_poly_without_overlapping;
                }


                // inside coverage without overlapping
                //var fv_formula = (10 * total_cir_cov_ins_poly_with_overlapping) - (9 * total_overlapping_amongall_circles);

                // inside coverage without overlapping
                //var fv_formula = total_cir_cov_ins_poly_without_overlapping;

                // inside coverage without overlapping and without outsdie covg
                //var fv_formula = total_cir_cov_ins_poly_without_overlapping - total_cir_cov_outs_poly;

                //var fv_formula = (total_cir_cov_ins_poly_with_overlapping + (2 * total_cir_cov_ins_poly_without_overlapping)) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly);
                //var fv_formula = 2 * (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_ins_poly_without_overlapping) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly);
                //var fv_formula = ((2 * total_cir_cov_ins_poly_with_overlapping) + total_cir_cov_ins_poly_without_overlapping) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly);


                coverage_results_with_n_without[0] = fv_formula; // fitness value
                coverage_results_with_n_without[1] = total_cir_cov_ins_poly_without_overlapping; // without overlapping
                coverage_results_with_n_without[2] = total_cir_cov_ins_poly_with_overlapping; // with overlapping
                coverage_results_with_n_without[3] = total_overlapping_amongall_circles; // total overlapping
                coverage_results_with_n_without[4] = total_cir_cov_outs_poly; // outside coverage
                coverage_results_with_n_without[5] = polygon_not_covered_points; // polygon_not_covered_points
                coverage_results_with_n_without[6] = eclipsed_circles_array; // circles those are eclipsed inside other circles
                coverage_results_with_n_without[7] = polygon_coverage.length - total_cir_cov_ins_poly_without_overlapping; // polygon points not covered
                coverage_results_with_n_without[8] = number_of_circles;
                coverage_results_with_n_without[9] = circle_radii_array;


                return coverage_results_with_n_without;

                //return total_cir_cov_ins_poly_without_overlapping;


                // fitness value
                var total_cir_cov = total_cir_cov_ins_poly_without_overlapping - total_cir_cov_outs_poly;


                //console.log("fitness value " + total_cir_cov);

                return total_cir_cov;



            }



            ////////////////////



            function Get_Circle_Outside_Coverage_Of_Record_Map(
                cartesian_record,
                map,
                polygon,
                polygon_coverage_on_latlong_grid,
                latlong_grid,
                circle_radii_array) {


                var center_point_array = [];
                for (var i = 0; i < cartesian_record.length; i++) {
                    center_point_array[i] = Map_Cartesian_Point_To_LatLong_Point(cartesian_record[i], latlong_grid); //new esri.geometry.Point({ "x": record[0][0], "y": record[0][1], "spatialReference": map.spatialReference });
                }


                // Zarooooori
                //var center_point_1 = Map_Cartesian_Point_To_LatLong_Point(cartesian_record[0], latlong_grid); //new esri.geometry.Point({ "x": record[0][0], "y": record[0][1], "spatialReference": map.spatialReference });
                //var center_point_2 = Map_Cartesian_Point_To_LatLong_Point(cartesian_record[1], latlong_grid); //new esri.geometry.Point({ "x": record[1][0], "y": record[1][1], "spatialReference": map.spatialReference });
                //var center_point_3 = Map_Cartesian_Point_To_LatLong_Point(cartesian_record[2], latlong_grid); //new esri.geometry.Point({ "x": record[2][0], "y": record[2][1], "spatialReference": map.spatialReference });
                //var center_point_4 = Map_Cartesian_Point_To_LatLong_Point(cartesian_record[3], latlong_grid); //new esri.geometry.Point({ "x": record[3][0], "y": record[3][1], "spatialReference": map.spatialReference });


                var circle_polygon_array = [];
                for (var i = 0; i < center_point_array.length; i++) {
                    circle_polygon_array[i] = get_circle_polygon(center_point_array[i], circle_radii_array[i]);
                }


                // Zarooori
                //var circle_polygon_1 = get_circle_polygon(center_point_1, circle_radii_array[0]);
                //var circle_polygon_2 = get_circle_polygon(center_point_2, circle_radii_array[1]);
                //var circle_polygon_3 = get_circle_polygon(center_point_3, circle_radii_array[2]);
                //var circle_polygon_4 = get_circle_polygon(center_point_4, circle_radii_array[3]);


                var cir_cov_on_grid = [];
                for (var i = 0; i < circle_polygon_array.length; i++) {
                    cir_cov_on_grid[i] = get_polygon_coverage_on_latlong_grid(circle_polygon_array[i], latlong_grid);
                }



                // Lat Long Points covered by a circle on grid
                //var cir1_cov_on_grid = get_polygon_coverage_on_latlong_grid(circle_polygon_1, latlong_grid);
                //var cir2_cov_on_grid = get_polygon_coverage_on_latlong_grid(circle_polygon_2, latlong_grid);
                //var cir3_cov_on_grid = get_polygon_coverage_on_latlong_grid(circle_polygon_3, latlong_grid);
                //var cir4_cov_on_grid = get_polygon_coverage_on_latlong_grid(circle_polygon_4, latlong_grid);


                var cir_cov_outs_poly = [];
                for (var i = 0; i < cir_cov_on_grid.length; i++) {
                    cir_cov_outs_poly[i] = get_circle_coverage_outside_polygon(polygon, cir_cov_on_grid[i]);
                }


                //var cir1_cov_outs_poly = get_circle_coverage_outside_polygon(polygon, cir1_cov_on_grid);
                //var cir2_cov_outs_poly = get_circle_coverage_outside_polygon(polygon, cir2_cov_on_grid);
                //var cir3_cov_outs_poly = get_circle_coverage_outside_polygon(polygon, cir3_cov_on_grid);
                //var cir4_cov_outs_poly = get_circle_coverage_outside_polygon(polygon, cir4_cov_on_grid);

                var total_cir_cov_outs_poly = 0;

                for (var i = 0; i < cir_cov_outs_poly.length; i++) {

                    total_cir_cov_outs_poly = total_cir_cov_outs_poly + cir_cov_outs_poly[i];
                }

                //var total_cir_cov_outs_poly = cir1_cov_outs_poly + cir2_cov_outs_poly + cir3_cov_outs_poly + cir4_cov_outs_poly;

                return total_cir_cov_outs_poly;

            }








            /////////////////////////////



            function print_point_array_to_console(points_array) {

                var output_str = "";

                for (var i = 0; i < points_array.length; i++) {
                    output_str = output_str + "[ " + points_array[i].x + " , " + points_array[i].y + " ] ";
                }

                console.log(output_str);
            }


            function find_overlapping_between_circles(cir_cov_ins_poly_1, cir_cov_ins_poly_2) {

                var overlappingcount = 0;

                for (var i = 0; i < cir_cov_ins_poly_1.length; i++) {

                    for (var j = 0; j < cir_cov_ins_poly_2.length; j++) {

                        if (cir_cov_ins_poly_1[i].x == cir_cov_ins_poly_2[j].x &&
                            cir_cov_ins_poly_1[i].y == cir_cov_ins_poly_2[j].y) {
                            overlappingcount++;
                            break;
                        }
                    }

                }

                return overlappingcount;
            }



            function get_circle_coverage_inside_polygon(circle, polygon_coverage) {

                //var circle_coverage = [];
                //var array_index = 0;

                var circle_coverage_inside_polygon = 0;

                for (var i = 0; i < polygon_coverage.length; i++) {

                    if (circle.contains(polygon_coverage[i])) {

                        //circle_coverage[array_index] = polygon_coverage[i];
                        //array_index++;
                        circle_coverage_inside_polygon++;

                    }

                }

                return circle_coverage_inside_polygon;
                //return circle_coverage;

            }



            function get_circle_coverage_points_inside_polygon(
                circle,
                polygon_coverage,
                duplicate_polygon_coverage) {

                var circle_coverage = [];
                var array_index = 0;


                for (var i = 0; i < polygon_coverage.length; i++) {

                    if (circle.contains(polygon_coverage[i])) {

                        circle_coverage[array_index] = polygon_coverage[i];
                        duplicate_polygon_coverage[i] = null;
                        array_index++;

                    }

                }

                return circle_coverage;

            }



            function get_circle_coverage_outside_polygon(polygon, circle_coverage) {

                //var circle_coverage = [];
                //var array_index = 0;

                var circle_coverage_outside_polygon = 0;

                for (var i = 0; i < circle_coverage.length; i++) {

                    if (!polygon.contains(circle_coverage[i])) {
                        circle_coverage_outside_polygon++;
                    }

                }

                return circle_coverage_outside_polygon;

            }


            function get_circle_coverage_points_outside_polygon(polygon, circle_coverage) {

                var circle_coverage = [];
                var array_index = 0;


                for (var i = 0; i < circle_coverage.length; i++) {

                    if (!polygon.contains(circle_coverage[i])) {

                        circle_coverage[array_index] = polygon_coverage[i];
                        array_index++;

                    }

                }

                return circle_coverage;

            }



            function show_record_on_map(
                graphics_layer,
                cartesian_record,
                latlong_grid,
                circle_radii_array,
                number_of_circles) {

                //console.error(cartesian_record);
                //console.error(latlong_grid);
                // console.error("cartesian_record" + cartesian_record);


                for (var i = 0; i < number_of_circles; i++) {

                    draw_circle(
                        graphics_layer,
                        Map_Cartesian_Point_To_LatLong_Point(cartesian_record[1][i], latlong_grid),
                        Get_Circle_Color(i + 1),
                        i + 1,
                        circle_radii_array[i]);

                }


                //draw_circle(graphics_layer, Map_Cartesian_Point_To_LatLong_Point(cartesian_record[1][0], latlong_grid), "blue", 1, radius_of_circle_in_meters);
                //draw_circle(graphics_layer, Map_Cartesian_Point_To_LatLong_Point(cartesian_record[1][1], latlong_grid), "green", 2, radius_of_circle_in_meters);
                //draw_circle(graphics_layer, Map_Cartesian_Point_To_LatLong_Point(cartesian_record[1][2], latlong_grid), "black", 3, radius_of_circle_in_meters);
                //draw_circle(graphics_layer, Map_Cartesian_Point_To_LatLong_Point(cartesian_record[1][3], latlong_grid), "red", 4, radius_of_circle_in_meters);
            }


            function Get_Circle_Color(choice) {


                if (choice == 1) {
                    return "blue";
                }


                if (choice == 2) {
                    return "green";
                }

                if (choice == 3) {
                    return "black";
                }

                if (choice == 4) {
                    return "red";
                }


                if (choice == 5) {
                    return "blue";
                }


                if (choice == 6) {
                    return "green";
                }

                if (choice == 7) {
                    return "black";
                }

                if (choice == 8) {
                    return "red";
                }



                if (choice % 2 == 0) {
                    return "blue";
                }


                if (choice % 3 == 0) {
                    return "green";
                }

                return "red";


            }



            function Get_Point_Symbolology(choice) {


                //var symbol = new SimpleMarkerSymbol();
                ////symbol.setColor(new Color(color));
                ////symbol.setOutline(null);
                //symbol.setSize("2");

                //var symbol = new SimpleMarkerSymbol(
                //    SimpleMarkerSymbol.STYLE_SQUARE,
                //    2,
                //    new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID,
                //        new esri.Color([255, 0, 0]), 1),
                //    new esri.Color([0, 255, 0, 0.25]));


                var symbology_black = new SimpleMarkerSymbol({
                    "color": [0, 0, 0, 255],
                    "size": 2,
                    "angle": -30,
                    "xoffset": 0,
                    "yoffset": 0,
                    "type": "esriSMS",
                    "style": "esriSMSCircle",
                    "outline": {
                        "color": [0, 0, 0, 255],
                        "width": 1,
                        "type": "esriSLS",
                        "style": "esriSLSSolid"
                    }
                });


                var symbology_red = new SimpleMarkerSymbol({
                    "color": [255, 0, 0, 255],
                    "size": 2,
                    "angle": -30,
                    "xoffset": 0,
                    "yoffset": 0,
                    "type": "esriSMS",
                    "style": "esriSMSCircle",
                    "outline": {
                        "color": [255, 0, 0, 255],
                        "width": 1,
                        "type": "esriSLS",
                        "style": "esriSLSSolid"
                    }
                });


                var symbology_green = new SimpleMarkerSymbol({
                    "color": [0, 255, 0, 255],
                    "size": 2,
                    "angle": -30,
                    "xoffset": 0,
                    "yoffset": 0,
                    "type": "esriSMS",
                    "style": "esriSMSCircle",
                    "outline": {
                        "color": [0, 255, 0, 255],
                        "width": 1,
                        "type": "esriSLS",
                        "style": "esriSLSSolid"
                    }
                });


                var symbology_blue = new SimpleMarkerSymbol({
                    "color": [0, 0, 255, 255],
                    "size": 2,
                    "angle": -30,
                    "xoffset": 0,
                    "yoffset": 0,
                    "type": "esriSMS",
                    "style": "esriSMSCircle",
                    "outline": {
                        "color": [0, 0, 255, 255],
                        "width": 1,
                        "type": "esriSLS",
                        "style": "esriSLSSolid"
                    }
                });



                // done
                var symbology_pink = new SimpleMarkerSymbol({
                    "color": [180, 2, 40, 255],
                    "size": 2,
                    "angle": -30,
                    "xoffset": 0,
                    "yoffset": 0,
                    "type": "esriSMS",
                    "style": "esriSMSCircle",
                    "outline": {
                        "color": [180, 2, 40, 255],
                        "width": 1,
                        "type": "esriSLS",
                        "style": "esriSLSSolid"
                    }
                });


                // done
                var symbology_orange = new SimpleMarkerSymbol({
                    "color": [230, 130, 2, 255],
                    "size": 2,
                    "angle": -30,
                    "xoffset": 0,
                    "yoffset": 0,
                    "type": "esriSMS",
                    "style": "esriSMSCircle",
                    "outline": {
                        "color": [230, 130, 2, 255],
                        "width": 1,
                        "type": "esriSLS",
                        "style": "esriSLSSolid"
                    }
                });



                // done
                var symbology_white = new SimpleMarkerSymbol({
                    "color": [0, 255, 255, 255],
                    "size": 2,
                    "angle": -30,
                    "xoffset": 0,
                    "yoffset": 0,
                    "type": "esriSMS",
                    "style": "esriSMSCircle",
                    "outline": {
                        "color": [255, 255, 255, 255],
                        "width": 1,
                        "type": "esriSLS",
                        "style": "esriSLSSolid"
                    }
                });


                // done
                var symbology_yellow = new SimpleMarkerSymbol({
                    "color": [220, 240, 45, 255],
                    "size": 2,
                    "angle": -30,
                    "xoffset": 0,
                    "yoffset": 0,
                    "type": "esriSMS",
                    "style": "esriSMSCircle",
                    "outline": {
                        "color": [220, 240, 45, 255],
                        "width": 1,
                        "type": "esriSLS",
                        "style": "esriSLSSolid"
                    }
                });





                if (choice == 1) {
                    return symbology_blue;
                }


                if (choice == 2) {
                    return symbology_green;
                }

                if (choice == 3) {
                    return symbology_black;
                }

                if (choice == 4) {
                    return symbology_red;
                }


                if (choice == 5) {
                    return symbology_blue;
                }

                if (choice == 6) {
                    return symbology_green;
                }

                if (choice == 7) {
                    return symbology_black;
                }


                if (choice == 8) {
                    return symbology_red;
                }



                if (choice % 2 == 0) {
                    return symbology_blue;
                }


                if (choice % 3 == 0) {
                    return symbology_green;
                }

                return symbology_red;

                //return symbol;

            }


            function Highligh_Point_On_Map(graphics_layer, circle_number, point) {

                var point_symbology = Get_Point_Symbolology(circle_number);
                point_symbology.size = 5;

                var infoTemplate = new esri.InfoTemplate();
                //infoTemplate.setTitle("${NAME}");
                infoTemplate.setContent("x " + point.x + "<br> y " + point.y + "<br> x " + point.cx + "<br> y " + point.cy);

                var graphic = new Graphic(point, point_symbology);
                graphic.setInfoTemplate(infoTemplate);
                graphics_layer.add(graphic);


            }


            function Show_Grid_Points_On_Map(graphics_layer, latlong_grid) {

                var point_symbology = Get_Point_Symbolology(3);


                //alert("latlong_grid.length"+latlong_grid.length);

                for (var i = 0; i < latlong_grid.length; i++) {

                    //alert("latlong_grid[0].length" + latlong_grid[0].length);

                    for (var j = 0; j < latlong_grid[i].length; j++) {

                        //console.log("callled " + i + " " + j);

                        var infoTemplate = new esri.InfoTemplate();
                        //infoTemplate.setTitle("${NAME}");
                        infoTemplate.setContent("x " + latlong_grid[i][j].x + "<br> y " + latlong_grid[i][j].y + "<br> x " + i + "<br> y " + j);

                        var graphic = new Graphic(latlong_grid[i][j], point_symbology);
                        graphic.setInfoTemplate(infoTemplate);
                        graphics_layer.add(graphic);


                    }
                }
            }


            function show_lat_long_points_on_map(graphics_layer, points_array) {

                var point_symbology = Get_Point_Symbolology(2);

                for (var i = 0; i < points_array.length; i++) {

                    var graphic = new Graphic(points_array[i], point_symbology);
                    graphics_layer.add(graphic);

                }
            }


            function get_polygon_coverage_on_latlong_grid(polygon, latlong_grid) {

                var polygon_coverage = [];
                var point = null;
                var array_index = 0;

                for (var i = 0; i < latlong_grid.length; i++) {

                    for (var j = 0; j < latlong_grid[i].length; j++) {

                        point = latlong_grid[i][j];//new esri.geometry.Point({ "x": latlong_grid[i][j][0], "y": latlong_grid[i][j][1], "spatialReference": map.spatialReference });

                        if (polygon.contains(point)) {

                            polygon_coverage[array_index] = point;
                            array_index++;
                        }
                    }
                }

                return polygon_coverage;

            }


            function get_polygon_coverage_count_on_latlong_grid(polygon, latlong_grid) {

                //var polygon_coverage = [];
                //var array_index = 0;
                var point = null;

                var polygon_coverage_count_on_latlong_grid = 0;

                for (var i = 0; i < latlong_grid.length; i++) {

                    for (var j = 0; j < latlong_grid[i].length; j++) {

                        point = latlong_grid[i][j];//new esri.geometry.Point({ "x": latlong_grid[i][j][0], "y": latlong_grid[i][j][1], "spatialReference": map.spatialReference });

                        if (polygon.contains(point)) {

                            polygon_coverage_count_on_latlong_grid++;
                        }
                    }
                }

                return polygon_coverage_count_on_latlong_grid;

            }




            function get_polygon_coverage_on_latlong_cartesian_grid(polygon, latlong_grid) {

                var polygon_coverage_on_latlong_grid = [];
                var polygon_coverage_on_cartesian_grid = [];
                var result_array = [];

                var latlong_point = null;
                var cartesian_point = null;
                var array_index = 0;

                for (var i = 0; i < latlong_grid.length; i++) {

                    for (var j = 0; j < latlong_grid[i].length; j++) {

                        latlong_point = latlong_grid[i][j];//new esri.geometry.Point({ "x": latlong_grid[i][j][0], "y": latlong_grid[i][j][1], "spatialReference": map.spatialReference });

                        cartesian_point = [];

                        if (polygon.contains(latlong_point)) {

                            polygon_coverage_on_latlong_grid[array_index] = latlong_point;
                            cartesian_point[0] = i;
                            cartesian_point[1] = j;
                            polygon_coverage_on_cartesian_grid[array_index] = cartesian_point;
                            array_index++;
                        }
                    }
                }

                result_array[0] = polygon_coverage_on_latlong_grid;
                result_array[1] = polygon_coverage_on_cartesian_grid;

                return result_array;

            }


            function draw_polygon(polygon_selector) {

                var polygon_rings;


                if (polygon_selector == 1) {
                    //1
                    polygon_rings = [
                        new esri.geometry.Point(8134141.592511637, 3987041.225819014, map.spatialReference),
                        new esri.geometry.Point(8137485.712499109, 3982550.550407266, map.spatialReference),
                        new esri.geometry.Point(8137485.712499109, 3982550.550407266, map.spatialReference),
                        new esri.geometry.Point(8126173.0323129175, 3986143.0907366644, map.spatialReference),
                        new esri.geometry.Point(8129058.53013068, 3987041.225819014, map.spatialReference),
                        new esri.geometry.Point(8134141.592511637, 3987041.225819014, map.spatialReference)
                    ];
                }


                if (polygon_selector == 2) {
                    //2
                    polygon_rings = [
                        new esri.geometry.Point(8130013.992984243, 3986850.133248301, map.spatialReference),
                        new esri.geometry.Point(8140275.664031514, 3986295.9647932346, map.spatialReference),
                        new esri.geometry.Point(8136128.955247048, 3984041.072458825, map.spatialReference),
                        new esri.geometry.Point(8131351.640979231, 3982455.0041219094, map.spatialReference),
                        new esri.geometry.Point(8128103.067277116, 3984614.350170963, map.spatialReference),
                        new esri.geometry.Point(8130013.992984243, 3986850.133248301, map.spatialReference)
                    ];
                }


                if (polygon_selector == 3) {
                    //3
                    polygon_rings = [
                        new esri.geometry.Point(8128791.000531682, 3987366.0831892258, map.spatialReference),
                        new esri.geometry.Point(8141001.815800222, 3985646.2500528116, map.spatialReference),
                        new esri.geometry.Point(8128332.378361971, 3983047.391091119, map.spatialReference),
                        new esri.geometry.Point(8130644.598467595, 3985512.4852533126, map.spatialReference),
                        new esri.geometry.Point(8128791.000531682, 3987366.0831892258, map.spatialReference)
                    ];
                }


                if (polygon_selector == 4) {
                    //4
                    polygon_rings = [
                        new esri.geometry.Point(8132268.885318653, 3987576.2850170094, map.spatialReference),
                        new esri.geometry.Point(8132708.398231291, 3985397.829710885, map.spatialReference),
                        new esri.geometry.Point(8137466.603242038, 3985244.9556543147, map.spatialReference),
                        new esri.geometry.Point(8129689.135614031, 3980907.1542991367, map.spatialReference),
                        new esri.geometry.Point(8128504.361675613, 3985264.064911386, map.spatialReference),
                        new esri.geometry.Point(8132268.885318653, 3987576.2850170094, map.spatialReference)
                    ];
                }


                if (polygon_selector == 5) {
                    //5
                    polygon_rings = [
                        new esri.geometry.Point(8128733.672760468, 3987289.6461609406, map.spatialReference),
                        new esri.geometry.Point(8130663.707724666, 3986926.5702765863, map.spatialReference),
                        new esri.geometry.Point(8139320.20117795, 3985130.300111887, map.spatialReference),
                        new esri.geometry.Point(8138364.738324387, 3983353.139204259, map.spatialReference),
                        new esri.geometry.Point(8128982.093102395, 3982149.2560087694, map.spatialReference),
                        new esri.geometry.Point(8126516.998940201, 3982970.954062834, map.spatialReference),
                        new esri.geometry.Point(8126784.528539198, 3984748.114970462, map.spatialReference),
                        new esri.geometry.Point(8127587.117336192, 3986353.2925644484, map.spatialReference),
                        new esri.geometry.Point(8128733.672760468, 3987289.6461609406, map.spatialReference)
                    ];
                }


                if (polygon_selector == 6) {
                    //6
                    polygon_rings = [
                        new esri.geometry.Point(8128619.01721804, 3986964.788790729, map.spatialReference),
                        new esri.geometry.Point(8130912.128066593, 3987155.8813614417, map.spatialReference),
                        new esri.geometry.Point(8133071.4741156455, 3987079.4443331566, map.spatialReference),
                        new esri.geometry.Point(8137065.308843541, 3986697.259191731, map.spatialReference),
                        new esri.geometry.Point(8139109.999350167, 3985474.26673917, map.spatialReference),
                        new esri.geometry.Point(8138976.234550668, 3984289.4928007512, map.spatialReference),
                        new esri.geometry.Point(8137925.225411748, 3982779.861492121, map.spatialReference),
                        new esri.geometry.Point(8135307.257192984, 3982531.4411501945, map.spatialReference),
                        new esri.geometry.Point(8130606.379953452, 3983009.1725769765, map.spatialReference),
                        new esri.geometry.Point(8127759.100649833, 3983620.668803257, map.spatialReference),
                        new esri.geometry.Point(8126497.889683129, 3985034.7538265307, map.spatialReference),
                        new esri.geometry.Point(8126784.528539198, 3986639.9314205176, map.spatialReference),
                        new esri.geometry.Point(8128619.01721804, 3986964.788790729, map.spatialReference)
                    ];
                }


                if (polygon_selector == 7) {
                    //7
                    polygon_rings = [
                        new esri.geometry.Point(8129765.572642316, 3987041.225819014, map.spatialReference),
                        new esri.geometry.Point(8135899.644162193, 3985913.779651809, map.spatialReference),
                        new esri.geometry.Point(8137523.931013251, 3985187.627883101, map.spatialReference),
                        new esri.geometry.Point(8135307.257192984, 3983066.5003481903, map.spatialReference),
                        new esri.geometry.Point(8132784.835259576, 3982569.659664337, map.spatialReference),
                        new esri.geometry.Point(8131867.590920156, 3982684.3152067647, map.spatialReference),
                        new esri.geometry.Point(8128103.067277116, 3982474.1133789807, map.spatialReference),
                        new esri.geometry.Point(8127663.554364477, 3984136.618744181, map.spatialReference),
                        new esri.geometry.Point(8128485.252418541, 3986219.5277649495, map.spatialReference),
                        new esri.geometry.Point(8129765.572642316, 3987041.225819014, map.spatialReference)
                    ];

                }



                if (polygon_selector == 8) {
                    //8
                    polygon_rings = [
                        new esri.geometry.Point(8124854.493575, 3987882.03313015, map.spatialReference),
                        new esri.geometry.Point(8142549.665622994, 3988589.0756417867, map.spatialReference),
                        new esri.geometry.Point(8141154.689856792, 3981079.137612778, map.spatialReference),
                        new esri.geometry.Point(8126249.469341204, 3980505.8599006403, map.spatialReference),
                        new esri.geometry.Point(8124854.493575, 3987882.03313015, map.spatialReference)
                    ];

                }



                if (polygon_selector == 9) {
                    //9
                    polygon_rings = [
                        new esri.geometry.Point(8124854.493575, 3987882.03313015, map.spatialReference),
                        new esri.geometry.Point(8142549.665622994, 3988589.0756417867, map.spatialReference),
                        new esri.geometry.Point(8141154.689856792, 3981079.137612778, map.spatialReference),
                        new esri.geometry.Point(8126249.469341204, 3980505.8599006403, map.spatialReference),
                        new esri.geometry.Point(8124854.493575, 3987882.03313015, map.spatialReference)
                    ];

                }


                if (polygon_selector == 10) {
                    //10
                    polygon_rings = [
                        new esri.geometry.Point(8137695.914326892, 3986372.4018215197, map.spatialReference),
                        new esri.geometry.Point(8141708.858311859, 3981843.507895629, map.spatialReference),
                        new esri.geometry.Point(8126765.419282127, 3985722.6870810967, map.spatialReference),
                        new esri.geometry.Point(8129306.950472606, 3981518.650525417, map.spatialReference),
                        new esri.geometry.Point(8137695.914326892, 3986372.4018215197, map.spatialReference)
                    ];

                }



                if (polygon_selector == 11) {
                    //11
                    polygon_rings = [
                        new esri.geometry.Point(8135918.753419264, 3987098.553590228, map.spatialReference),
                        new esri.geometry.Point(8130682.8169817375, 3981633.306067845, map.spatialReference),
                        new esri.geometry.Point(8134982.3998227725, 3984365.9298290364, map.spatialReference),
                        new esri.geometry.Point(8125332.225001782, 3982034.6004663417, map.spatialReference),
                        new esri.geometry.Point(8135918.753419264, 3987098.553590228, map.spatialReference)
                    ];

                }



                if (polygon_selector == 12) {
                    //12
                    polygon_rings = [
                        new esri.geometry.Point(8138460.284609743, 3984767.224227533, map.spatialReference),
                        new esri.geometry.Point(8142186.589738641, 3988512.6386135016, map.spatialReference),
                        new esri.geometry.Point(8128064.848762973, 3981499.541268346, map.spatialReference),
                        new esri.geometry.Point(8131963.137205512, 3985646.2500528116, map.spatialReference),
                        new esri.geometry.Point(8137523.931013251, 3986811.9147341587, map.spatialReference),
                        new esri.geometry.Point(8138460.284609743, 3984767.224227533, map.spatialReference)
                    ];

                }

                var polygon_symbol = new SimpleFillSymbol().setColor(null).outline.setColor("red").setWidth(3);

                var polygon = new Polygon();
                polygon.addRing(polygon_rings);
                polygon.spatialReference = map.spatialReference;
                var polygon_graphic = new esri.Graphic(polygon, polygon_symbol, { keeper: true });

                graphics_layer.add(polygon_graphic);

                var drawings_results = [];

                drawings_results[0] = polygon;
                drawings_results[1] = polygon_graphic;

                return drawings_results;

            }


            function get_polygon(polygon_selector) {


                if (polygon_selector == 1) {
                    //1
                    polygon_rings = [
                        new esri.geometry.Point(8134141.592511637, 3987041.225819014, map.spatialReference),
                        new esri.geometry.Point(8137485.712499109, 3982550.550407266, map.spatialReference),
                        new esri.geometry.Point(8137485.712499109, 3982550.550407266, map.spatialReference),
                        new esri.geometry.Point(8126173.0323129175, 3986143.0907366644, map.spatialReference),
                        new esri.geometry.Point(8129058.53013068, 3987041.225819014, map.spatialReference),
                        new esri.geometry.Point(8134141.592511637, 3987041.225819014, map.spatialReference)
                    ];
                }


                if (polygon_selector == 2) {
                    //2
                    polygon_rings = [
                        new esri.geometry.Point(8130013.992984243, 3986850.133248301, map.spatialReference),
                        new esri.geometry.Point(8140275.664031514, 3986295.9647932346, map.spatialReference),
                        new esri.geometry.Point(8136128.955247048, 3984041.072458825, map.spatialReference),
                        new esri.geometry.Point(8131351.640979231, 3982455.0041219094, map.spatialReference),
                        new esri.geometry.Point(8128103.067277116, 3984614.350170963, map.spatialReference),
                        new esri.geometry.Point(8130013.992984243, 3986850.133248301, map.spatialReference)
                    ];
                }


                if (polygon_selector == 3) {
                    //3
                    polygon_rings = [
                        new esri.geometry.Point(8128791.000531682, 3987366.0831892258, map.spatialReference),
                        new esri.geometry.Point(8141001.815800222, 3985646.2500528116, map.spatialReference),
                        new esri.geometry.Point(8128332.378361971, 3983047.391091119, map.spatialReference),
                        new esri.geometry.Point(8130644.598467595, 3985512.4852533126, map.spatialReference),
                        new esri.geometry.Point(8128791.000531682, 3987366.0831892258, map.spatialReference)
                    ];
                }


                if (polygon_selector == 4) {
                    //4
                    polygon_rings = [
                        new esri.geometry.Point(8132268.885318653, 3987576.2850170094, map.spatialReference),
                        new esri.geometry.Point(8132708.398231291, 3985397.829710885, map.spatialReference),
                        new esri.geometry.Point(8137466.603242038, 3985244.9556543147, map.spatialReference),
                        new esri.geometry.Point(8129689.135614031, 3980907.1542991367, map.spatialReference),
                        new esri.geometry.Point(8128504.361675613, 3985264.064911386, map.spatialReference),
                        new esri.geometry.Point(8132268.885318653, 3987576.2850170094, map.spatialReference)
                    ];
                }


                if (polygon_selector == 5) {
                    //5
                    polygon_rings = [
                        new esri.geometry.Point(8128733.672760468, 3987289.6461609406, map.spatialReference),
                        new esri.geometry.Point(8130663.707724666, 3986926.5702765863, map.spatialReference),
                        new esri.geometry.Point(8139320.20117795, 3985130.300111887, map.spatialReference),
                        new esri.geometry.Point(8138364.738324387, 3983353.139204259, map.spatialReference),
                        new esri.geometry.Point(8128982.093102395, 3982149.2560087694, map.spatialReference),
                        new esri.geometry.Point(8126516.998940201, 3982970.954062834, map.spatialReference),
                        new esri.geometry.Point(8126784.528539198, 3984748.114970462, map.spatialReference),
                        new esri.geometry.Point(8127587.117336192, 3986353.2925644484, map.spatialReference),
                        new esri.geometry.Point(8128733.672760468, 3987289.6461609406, map.spatialReference)
                    ];
                }


                if (polygon_selector == 6) {
                    //6
                    polygon_rings = [
                        new esri.geometry.Point(8128619.01721804, 3986964.788790729, map.spatialReference),
                        new esri.geometry.Point(8130912.128066593, 3987155.8813614417, map.spatialReference),
                        new esri.geometry.Point(8133071.4741156455, 3987079.4443331566, map.spatialReference),
                        new esri.geometry.Point(8137065.308843541, 3986697.259191731, map.spatialReference),
                        new esri.geometry.Point(8139109.999350167, 3985474.26673917, map.spatialReference),
                        new esri.geometry.Point(8138976.234550668, 3984289.4928007512, map.spatialReference),
                        new esri.geometry.Point(8137925.225411748, 3982779.861492121, map.spatialReference),
                        new esri.geometry.Point(8135307.257192984, 3982531.4411501945, map.spatialReference),
                        new esri.geometry.Point(8130606.379953452, 3983009.1725769765, map.spatialReference),
                        new esri.geometry.Point(8127759.100649833, 3983620.668803257, map.spatialReference),
                        new esri.geometry.Point(8126497.889683129, 3985034.7538265307, map.spatialReference),
                        new esri.geometry.Point(8126784.528539198, 3986639.9314205176, map.spatialReference),
                        new esri.geometry.Point(8128619.01721804, 3986964.788790729, map.spatialReference)
                    ];
                }


                if (polygon_selector == 7) {
                    //7
                    polygon_rings = [
                        new esri.geometry.Point(8129765.572642316, 3987041.225819014, map.spatialReference),
                        new esri.geometry.Point(8135899.644162193, 3985913.779651809, map.spatialReference),
                        new esri.geometry.Point(8137523.931013251, 3985187.627883101, map.spatialReference),
                        new esri.geometry.Point(8135307.257192984, 3983066.5003481903, map.spatialReference),
                        new esri.geometry.Point(8132784.835259576, 3982569.659664337, map.spatialReference),
                        new esri.geometry.Point(8131867.590920156, 3982684.3152067647, map.spatialReference),
                        new esri.geometry.Point(8128103.067277116, 3982474.1133789807, map.spatialReference),
                        new esri.geometry.Point(8127663.554364477, 3984136.618744181, map.spatialReference),
                        new esri.geometry.Point(8128485.252418541, 3986219.5277649495, map.spatialReference),
                        new esri.geometry.Point(8129765.572642316, 3987041.225819014, map.spatialReference)
                    ];

                }



                if (polygon_selector == 8) {
                    //8
                    polygon_rings = [
                        new esri.geometry.Point(8124854.493575, 3987882.03313015, map.spatialReference),
                        new esri.geometry.Point(8142549.665622994, 3988589.0756417867, map.spatialReference),
                        new esri.geometry.Point(8141154.689856792, 3981079.137612778, map.spatialReference),
                        new esri.geometry.Point(8126249.469341204, 3980505.8599006403, map.spatialReference),
                        new esri.geometry.Point(8124854.493575, 3987882.03313015, map.spatialReference)
                    ];

                }


                if (polygon_selector == 9) {
                    //9
                    polygon_rings = [
                        new esri.geometry.Point(8124854.493575, 3987882.03313015, map.spatialReference),
                        new esri.geometry.Point(8142549.665622994, 3988589.0756417867, map.spatialReference),
                        new esri.geometry.Point(8141154.689856792, 3981079.137612778, map.spatialReference),
                        new esri.geometry.Point(8126249.469341204, 3980505.8599006403, map.spatialReference),
                        new esri.geometry.Point(8124854.493575, 3987882.03313015, map.spatialReference)
                    ];

                }


                if (polygon_selector == 10) {
                    //10
                    polygon_rings = [
                        new esri.geometry.Point(8137695.914326892, 3986372.4018215197, map.spatialReference),
                        new esri.geometry.Point(8141708.858311859, 3981843.507895629, map.spatialReference),
                        new esri.geometry.Point(8126765.419282127, 3985722.6870810967, map.spatialReference),
                        new esri.geometry.Point(8129306.950472606, 3981518.650525417, map.spatialReference),
                        new esri.geometry.Point(8137695.914326892, 3986372.4018215197, map.spatialReference)
                    ];

                }



                if (polygon_selector == 11) {
                    //11
                    polygon_rings = [
                        new esri.geometry.Point(8135918.753419264, 3987098.553590228, map.spatialReference),
                        new esri.geometry.Point(8130682.8169817375, 3981633.306067845, map.spatialReference),
                        new esri.geometry.Point(8134982.3998227725, 3984365.9298290364, map.spatialReference),
                        new esri.geometry.Point(8125332.225001782, 3982034.6004663417, map.spatialReference),
                        new esri.geometry.Point(8135918.753419264, 3987098.553590228, map.spatialReference)
                    ];

                }



                if (polygon_selector == 12) {
                    //12
                    polygon_rings = [
                        new esri.geometry.Point(8138460.284609743, 3984767.224227533, map.spatialReference),
                        new esri.geometry.Point(8142186.589738641, 3988512.6386135016, map.spatialReference),
                        new esri.geometry.Point(8128064.848762973, 3981499.541268346, map.spatialReference),
                        new esri.geometry.Point(8131963.137205512, 3985646.2500528116, map.spatialReference),
                        new esri.geometry.Point(8137523.931013251, 3986811.9147341587, map.spatialReference),
                        new esri.geometry.Point(8138460.284609743, 3984767.224227533, map.spatialReference)
                    ];

                }


                var polygon_symbol = new SimpleFillSymbol().setColor(null).outline.setColor("red");
                var polygon = new Polygon();
                polygon.addRing(polygon_rings);
                polygon.spatialReference = map.spatialReference;
                var polygon_graphic = new esri.Graphic(polygon, polygon_symbol, { keeper: true });


                var drawings_results = [];

                drawings_results[0] = polygon;
                drawings_results[1] = polygon_graphic;

                return drawings_results;

            }


            function draw_circle(graphics_layer, circle_center, color, cir_number, radius_in_meters) {

                var circle_geometry = new Circle({
                    center: circle_center,
                    radius: radius_in_meters,
                    geodesic: true
                });

                var circle_label_text = cir_number + "(" + radius_in_meters / 1000 + ")";

                var circle_color = null;
                if (color == null || color == "") {
                    circle_color = "blue";
                }
                else {
                    circle_color = color;
                }

                if (cir_number != null) {

                    //alert("cccccccccccccc");
                    var font = Font("20px", Font.STYLE_NORMAL, Font.VARIANT_NORMAL, Font.WEIGHT_BOLDER);
                    var textSymbol = new TextSymbol(circle_label_text, font, circle_color);
                    var labelPointGraphic = new Graphic(circle_center.offset(100, 100), textSymbol);
                    graphics_layer.add(labelPointGraphic);
                }


                var circle_symbol = new SimpleFillSymbol().setColor(null).outline.setColor(circle_color).setWidth(2);

                var circle_geometry_rings = circle_geometry.rings;

                var circle_rings = [];

                for (var i = 0; i < circle_geometry_rings[0].length; i++) {
                    circle_rings[i] = new esri.geometry.Point(circle_geometry_rings[0][i][0], circle_geometry_rings[0][i][1], map.spatialReference);
                }


                var circle_polygon = new Polygon();
                circle_polygon.addRing(circle_rings);
                circle_polygon.spatialReference = map.spatialReference;

                var circle_graphic = new esri.Graphic(circle_polygon, circle_symbol, { keeper: true });

                graphics_layer.add(circle_graphic);


                Highligh_Point_On_Map(graphics_layer, cir_number, circle_center);

                var drawings_results = [];

                drawings_results[0] = circle_polygon;
                drawings_results[1] = circle_graphic;

                //METERS MILES SQUARE_KILOMETERS SQUARE_METERS SQUARE_MILES
                //var polygon_areas = geodesicUtils.geodesicAreas([circle_polygon], esri.Units.SQUARE_METERS);
                //var polygon_area = Math.round(polygon_areas[0]);
                //alert("Circle Area: " + polygon_area + " km²"); // Area: 1150498 km²


                //UNIT_METER UNIT_KILOMETER UNIT_SQUARE_METERS UNIT_SQUARE_KILOMETERS UNIT_SQUARE_MILES
                //setup the parameters for the areas and lengths operation
                //var areasAndLengthParams = new AreasAndLengthsParameters();
                //areasAndLengthParams.lengthUnit = GeometryService.UNIT_KILOMETER;
                //areasAndLengthParams.areaUnit = GeometryService.UNIT_SQUARE_KILOMETERS;
                //areasAndLengthParams.calculationType = "geodesic"; //planar, geodesic, preserveShape
                //geometryService.simplify([circle_polygon], function (simplifiedGeometries) {

                //    // Polygon geometries for which to compute areas and lengths
                //    areasAndLengthParams.polygons = simplifiedGeometries;
                //    geometryService.areasAndLengths(areasAndLengthParams, function (measurements) {
                //        // do something with the results here
                //        //var result = measurements.result;
                //        console.log("result" + measurements);
                //        console.log("area " + measurements.areas[0].toFixed(3) + " km2");
                //        console.log("length " + measurements.lengths[0].toFixed(3) + " km");
                //    });

                //});


                return drawings_results;
            }


            function get_circle_polygon(circle_center, radius_of_circle_in_meters) {

                var circle_geometry = new Circle({
                    center: circle_center,
                    radius: radius_of_circle_in_meters,
                    geodesic: true
                });

                var circle_symbol = new SimpleFillSymbol().setColor(null).outline.setColor("blue");

                var circle_geometry_rings = circle_geometry.rings;

                var circle_rings = [];

                for (var i = 0; i < circle_geometry_rings[0].length; i++) {
                    circle_rings[i] = new esri.geometry.Point(circle_geometry_rings[0][i][0], circle_geometry_rings[0][i][1], map.spatialReference);
                }


                var circle_polygon = new Polygon();
                circle_polygon.addRing(circle_rings);
                circle_polygon.spatialReference = map.spatialReference;

                return circle_polygon;
                //var circle_graphic = new esri.Graphic(circle_polygon, circle_symbol, { keeper: true });
                //var drawings_results = [];
                //drawings_results[0] = circle_polygon;
                //drawings_results[1] = circle_graphic;
                //return drawings_results;
            }




            //function Generate_Lat_Long_Points_Grid(polygon_extent, grid_length, map) {

            //    //xmax == Top - right X - coordinate of an extent envelope.
            //    //xmin == Bottom - left X - coordinate of an extent envelope.
            //    //ymax == Top - right Y - coordinate of an extent envelope.
            //    //ymin == Bottom - left Y - coordinate of an extent envelope.

            //    //var grid_length = 11;
            //    var grid = [];

            //    var xmax = polygon_extent.xmax;
            //    var xmin = polygon_extent.xmin;
            //    var ymax = polygon_extent.ymax;
            //    var ymin = polygon_extent.ymin;

            //    var x_distance = xmax - xmin;
            //    var y_distance = ymax - ymin;
            //    var x_interval = (xmax - xmin) / (grid_length - 1);
            //    var y_interval = (ymax - ymin) / (grid_length - 1);
            //    var x_point = null;
            //    var y_point = null;


            //    for (var i = 0; i < grid_length; i++) {

            //        var grid_row = [];

            //        for (var j = 0; j < grid_length; j++) {

            //            var grid_point = null;

            //            x_point = xmin + (j * x_interval);
            //            y_point = ymin + (i * y_interval);

            //            grid_point = new esri.geometry.Point({ "x": x_point, "y": y_point, "spatialReference": map.spatialReference });

            //            grid_row[j] = grid_point;
            //        }

            //        grid[i] = grid_row;

            //    }

            //    console.log(("xmax " + xmax));
            //    console.log(("ymax " + ymax));
            //    console.log(("xmin " + xmin));
            //    console.log(("ymin " + ymin));
            //    console.log(("x_distance" + x_distance));
            //    console.log(("y_distance" + y_distance));
            //    console.log(("x_interval" + x_interval));
            //    console.log(("y_interval" + y_interval));

            //    return grid;
            //}



            function createToolbar() {

                toolbar = new Draw(map);
                toolbar.on("draw-end", addToMap);

            }


            function addToMap(evt) {

                var symbol;
                toolbar.deactivate();
                map.showZoomSlider();

                switch (evt.geometry.type) {
                    case "point":
                    case "multipoint":
                        symbol = new SimpleMarkerSymbol();
                        break;
                    case "polyline":
                        symbol = new SimpleLineSymbol();
                        break;
                    case "polygon":
                        symbol = new SimpleFillSymbol();
                        break;
                    default:
                        symbol = new SimpleFillSymbol();
                        break;
                }

                //console.error(evt.geometry);

                var poly_rings_obj = evt.geometry.rings[0];

                var str = "";
                var hand_drawn_polygon_rings = [];

                for (var i = 0; i < poly_rings_obj.length; i++) {

                    str = str + " new esri.geometry.Point(" + poly_rings_obj[i][0] + ", " + poly_rings_obj[i][1] + ", map.spatialReference),";
                    hand_drawn_polygon_rings[i] = new esri.geometry.Point(poly_rings_obj[i][0], poly_rings_obj[i][1], map.spatialReference);
                }

                //console.error(str);

                //var polygon_symbol = new SimpleFillSymbol().setColor(null).outline.setColor("red");
                hand_drawn_polygon_by_user = new Polygon();
                hand_drawn_polygon_by_user.addRing(hand_drawn_polygon_rings);
                hand_drawn_polygon_by_user.spatialReference = map.spatialReference;

                execut_algo(hand_drawn_polygon_by_user);

                //var graphic = new Graphic(evt.geometry, symbol);
                //map.graphics.add(graphic);
            }


            function activateTool() {

                //alert("activateTool");
                //var tool = this.label.toUpperCase().replace(/ /g, "_");
                var tool = "polygon".toUpperCase().replace(/ /g, "_");
                toolbar.activate(Draw[tool]);
                map.hideZoomSlider();

                console.clear();
                graphics_layer.clear();

            }

            //permutator([1,2,3]);
            function permutator(inputArrLength) {

                var inputArr = [];

                for (var i = 0; i <= inputArrLength; i++) {
                    inputArr[i] = i;
                }


                var results = [];

                function permute(arr, memo) {
                    var cur, memo = memo || [];

                    for (var i = 0; i < arr.length; i++) {
                        cur = arr.splice(i, 1);
                        if (arr.length === 0) {
                            results.push(memo.concat(cur));
                        }
                        permute(arr.slice(), memo.concat(cur));
                        arr.splice(i, 0, cur[0]);
                    }

                    return results;
                }

                return permute(inputArr);
            }

            //console.log(permute([1, 2, 3]));
            function permute(permutationlength) {

                var permutation = [];

                for (var i = 0; i < permutationlength; i++) {
                    permutation[i] = i;
                }


                var length = permutation.length,
                    result = [permutation.slice()],
                    c = new Array(length).fill(0),
                    i = 1, k, p;

                while (i < length) {
                    if (c[i] < i) {
                        k = i % 2 && c[i];
                        p = permutation[i];
                        permutation[i] = permutation[k];
                        permutation[k] = p;
                        ++c[i];
                        i = 1;
                        result.push(permutation.slice());
                    } else {
                        c[i] = 0;
                        ++i;
                    }
                }
                return result;
            }



        });


        function Reset_UI_To_Start_Over_Again() {

            document.getElementById('txtAreaMargin').value = 0;

        }




    </script>
</head>

<body class="nihilo">

    <div id="mainWindow" data-dojo-type="dijit/layout/BorderContainer" data-dojo-props="design:'headline'">
        <div id="header" data-dojo-type="dijit/layout/ContentPane" data-dojo-props="region:'top'">

            <table>

                <tr>
                    <td colspan="4">
                        <label><b>Radii</b></label>

                        <label><input checked type="checkbox" name="chkbox_radii[]" value="5000" /> 5</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="4500" /> 4.5</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="4000" /> 4.0</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="3500" /> 3.5</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="3000" /> 3</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="2500" /> 2.5</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="2000" /> 2</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="1500" /> 1.5</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="1000" /> 1</label>
                        <label><input checked type="checkbox" name="chkbox_radii[]" value="500" /> 0.5</label>

                        <!--<label><input type="checkbox" name="sports[]" value="2500" /> 5.5</label>
                        <label><input type="checkbox" name="sports[]" value="3000" /> 6</label>-->

                    </td>
                    <!--<td> <input type="text" id="txtCircles" value="4" style="width:50px;"> </td>

                    <td> <label>Radius (m)</label></td>
                    <td> <input type="text" id="txtRadius" value="1500" style="width:50px;"></td>-->

                    <td> <label><b>Grid Density</b></label></td>
                    <td> <input type="text" id="txtGridLength" value="15" style="width:50px;"></td>

                    <td> <label><b>Random Sets</b></label> </td>
                    <td>  <input type="text" id="txtRandomSet" value="30" style="width:50px;"></td>

                    <td>  <label><b>Cross Over Sets</b></label> </td>
                    <td>  <input type="text" id="txtCrossOverSet" value="30" style="width:50px;"> </td>

                </tr>


                <tr>

                    <td> <label><b>Prev. Gen Sets</b></label> </td>
                    <td>  <input type="text" id="txtPrevGenerationSets" value="10" style="width:50px;"> </td>

                    <td><label><b>Generations</b></label></td>
                    <td> <input type="text" id="txtGenerations" value="10" style="width:50px;"></td>

                    <td>  <label><b>Mutate After Gen.</b></label> </td>
                    <td>  <input type="text" id="txtMutateAfter" value="4" style="width:50px;"></td>

                    <td> <label title="Margin-Area added to Polygon-Area to makeup for Circles-Overlappings & Outside-Coverage & Not-Covered-Area"><b>Area Margin (%) </b></label></td>
                    <td>  <input title="Margin-Area added to Polygon-Area to makeup for Circles-Overlappings & Outside-Coverage & Not-Covered-Area" type="text" id="txtAreaMargin" value="0" style="width:50px;"></td>

                    <td> <label><b>Bound Margin (%) </b></label></td>
                    <td>  <input type="text" id="txtBoundMargin" value="5" style="width:50px;"></td>

                </tr>


                <tr>
                    <td> <label><b>Polygon</b></label> </td>
                    <td>
                        <select name="cars" id="selectPolygon" onch onchange="Reset_UI_To_Start_Over_Again();">
                            <option value="1">One</option>
                            <option value="2">Two</option>
                            <option value="3">Three</option>
                            <option value="4">Four</option>
                            <option value="5">Five</option>
                            <option value="6">Six</option>
                            <option value="7">Seven</option>
                            <option value="8">Eight</option>
                            <option value="9">Nine</option>
                            <option value="10">Ten</option>
                            <option value="11">Eleven</option>
                            <option value="12">Twelve</option>
                        </select>
                    </td>

                    <td>
                        <button data-dojo-props="id:'btnExecutAlgo'" data-dojo-type="dijit/form/Button">Find & Improve Covg.</button>
                    </td>

                    <td>
                        <button data-dojo-props="id:'btnDrawPolygon'" data-dojo-type="dijit/form/Button">Draw Polygon</button>
                    </td>

                    <td>
                        <button data-dojo-props="id:'btnReevaluatePolygonCoverage'" data-dojo-type="dijit/form/Button"> Find & Improve Covg.</button>
                    </td>


                    <td colspan="2">
                        <button data-dojo-props="id:'btnResetGAParams'" data-dojo-type="dijit/form/Button">Reset GA Params</button>
                        <button data-dojo-props="id:'btnClearMap'" data-dojo-type="dijit/form/Button">Clear Map</button>
                    </td>


                    <td> <label title="Whether to use Model Solver or Custom Algo for finding No-Of-Circles & Circle-Radii"><b>Model Solver </b></label></td>
                    <td> <input title="Whether to use Model Solver or Custom Algo for finding No-Of-Circles & Circle-Radii" id="ckbModelSolver" checked type="checkbox" /></td>



                </tr>


                <tr>

                    <td> <label title="Different Fitness Formulaii used to evaluate."><b>Fit. Function </b></label></td>
                    <td colspan="2">
                        <input checked name="rdobtn_fitfun[]" type="radio" value="1" title="total_cir_cov_ins_poly_without_overlapping" />
                        <input name="rdobtn_fitfun[]" type="radio" value="2" title="(total_cir_cov_ins_poly_with_overlapping + (2 * total_cir_cov_ins_poly_without_overlapping)) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly)" />
                        <input name="rdobtn_fitfun[]" type="radio" value="3" title="(total_cir_cov_ins_poly_with_overlapping + (3 * total_cir_cov_ins_poly_without_overlapping)) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly)" />
                        <input name="rdobtn_fitfun[]" type="radio" value="4" title="(total_cir_cov_ins_poly_with_overlapping + (4 * total_cir_cov_ins_poly_without_overlapping)) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly)" />
                        <input name="rdobtn_fitfun[]" type="radio" value="5" title="total_cir_cov_ins_poly_without_overlapping - total_cir_cov_outs_poly" />
                        <input name="rdobtn_fitfun[]" type="radio" value="6" title="2 * (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_ins_poly_without_overlapping) - (total_cir_cov_ins_poly_with_overlapping + total_cir_cov_outs_poly)" />
                    </td>


                    <td> <label title="Two different ways to find outside coverage."><b>Out Covg Fltr</b></label></td>
                    <td colspan="2">
                        <input title="Only counts circle outside area that lies on grid." name="rdobtn_outsidecovgfilter[]" type="radio" value="1" />
                        <input title="Counts full circle outside area that lies outside the polygon." checked name="rdobtn_outsidecovgfilter[]" type="radio" value="2" />
                    </td>



                </tr>


            </table>



            <!--<button data-dojo-type="dijit/form/Button">Polygon</button>-->


        </div>
        <div id="map" data-dojo-type="dijit/layout/ContentPane" data-dojo-props="region:'center'"></div>
    </div>

</body>


</html>
